<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classhpx_1_1parallel_1_1v2_1_1task__block" kind="class" language="C++" prot="public">
    <compoundname>hpx::parallel::v2::task_block</compoundname>
    <includes refid="task__block_8hpp" local="no">task_block.hpp</includes>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>ExPolicy</declname>
        <defname>ExPolicy</defname>
        <defval>parallel::execution::parallel_policy</defval>
      </param>
    </templateparamlist>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classhpx_1_1parallel_1_1v2_1_1task__block_1aab56ea8bdf25594112ccab9889c3e294" prot="public" static="no">
        <type>ExPolicy</type>
        <definition>typedef ExPolicy hpx::parallel::v2::task_block&lt; ExPolicy &gt;::execution_policy</definition>
        <argsstring></argsstring>
        <name>execution_policy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Refers to the type of the execution policy used to create the <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="207" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="207" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a7b2dc2eea923d591eb814e432ec597b2" prot="private" static="no" mutable="yes">
        <type>mutex_type</type>
        <definition>mutex_type hpx::parallel::v2::task_block&lt; ExPolicy &gt;::mtx_</definition>
        <argsstring></argsstring>
        <name>mtx_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="372" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="372" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classhpx_1_1parallel_1_1v2_1_1task__block_1acf5200a8cf8e8866fcd5885c2de4cfe6" prot="private" static="no" mutable="no">
        <type>std::vector&lt; hpx::future&lt; void &gt; &gt;</type>
        <definition>std::vector&lt;hpx::future&lt;void&gt; &gt; hpx::parallel::v2::task_block&lt; ExPolicy &gt;::tasks_</definition>
        <argsstring></argsstring>
        <name>tasks_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="373" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="373" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a01521453dc95bf19d361bd99e2d0c4aa" prot="private" static="no" mutable="no">
        <type>parallel::exception_list</type>
        <definition>parallel::exception_list hpx::parallel::v2::task_block&lt; ExPolicy &gt;::errors_</definition>
        <argsstring></argsstring>
        <name>errors_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="374" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="374" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a3ac0cb819cb10fa1847d8207228b81ba" prot="private" static="no" mutable="no">
        <type>threads::thread_id_type</type>
        <definition>threads::thread_id_type hpx::parallel::v2::task_block&lt; ExPolicy &gt;::id_</definition>
        <argsstring></argsstring>
        <name>id_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="375" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="375" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a4cbbea8135c1507e713de14d0e8be80b" prot="private" static="no" mutable="no">
        <type>ExPolicy</type>
        <definition>ExPolicy hpx::parallel::v2::task_block&lt; ExPolicy &gt;::policy_</definition>
        <argsstring></argsstring>
        <name>policy_</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="376" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="376" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classhpx_1_1parallel_1_1v2_1_1task__block_1ac6a81aa62ea26bd2b790b573af04bac6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block_1aab56ea8bdf25594112ccab9889c3e294" kindref="member">execution_policy</ref> const  &amp;</type>
        <definition>execution_policy const&amp; hpx::parallel::v2::task_block&lt; ExPolicy &gt;::get_execution_policy</definition>
        <argsstring>() const</argsstring>
        <name>get_execution_policy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the execution policy instance used to create this <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="211" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="211" bodyend="211"/>
      </memberdef>
      <memberdef kind="function" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a942ef260b49d3bd93b3f63df973b577b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::parallel::v2::task_block&lt; ExPolicy &gt;::run</definition>
        <argsstring>(F &amp;&amp;f, Ts &amp;&amp;... ts)</argsstring>
        <name>run</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>ts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Causes the expression f() to be invoked asynchronously. The invocation of f is permitted to run on an unspecified thread in an unordered fashion relative to the sequence of operations following the call to run(f) (the continuation), or indeterminately sequenced within the same thread as the continuation.</para><para>The call to <emphasis>run</emphasis> synchronizes with the invocation of f. The completion of f() synchronizes with the next invocation of wait on the same <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> or completion of the nearest enclosing task block (i.e., the <emphasis>define_task_block</emphasis> or <emphasis>define_task_block_restore_thread</emphasis> that created this task block).</para><para>Requires: F shall be MoveConstructible. The expression, (void)f(), shall be well-formed.</para><para>Precondition: this shall be the active <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref>.</para><para>Postconditions: A call to run may return on a different thread than that on which it was called.</para><para><simplesect kind="note"><para>The call to <emphasis>run</emphasis> is sequenced before the continuation as if <emphasis>run</emphasis> returns on the same thread. The invocation of the user-supplied callable object f may be immediate or may be delayed until compute resources are available. <emphasis>run</emphasis> might or might not return before invocation of f completes.</para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>This</parametername>
</parameternamelist>
<parameterdescription>
<para>function may throw <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__canceled__exception" kindref="compound">task_canceled_exception</ref></emphasis>, as described in Exception Handling. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="244" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="244" bodyend="263"/>
      </memberdef>
      <memberdef kind="function" id="classhpx_1_1parallel_1_1v2_1_1task__block_1ad19e4cb24036c2adbd421cec62926821" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Executor</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::parallel::v2::task_block&lt; ExPolicy &gt;::run</definition>
        <argsstring>(Executor &amp;exec, F &amp;&amp;f, Ts &amp;&amp;... ts)</argsstring>
        <name>run</name>
        <param>
          <type>Executor &amp;</type>
          <declname>exec</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>ts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Causes the expression f() to be invoked asynchronously using the given executor. The invocation of f is permitted to run on an unspecified thread associated with the given executor and in an unordered fashion relative to the sequence of operations following the call to run(exec, f) (the continuation), or indeterminately sequenced within the same thread as the continuation.</para><para>The call to <emphasis>run</emphasis> synchronizes with the invocation of f. The completion of f() synchronizes with the next invocation of wait on the same <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> or completion of the nearest enclosing task block (i.e., the <emphasis>define_task_block</emphasis> or <emphasis>define_task_block_restore_thread</emphasis> that created this task block).</para><para>Requires: Executor shall be a type modeling the Executor concept. F shall be MoveConstructible. The expression, (void)f(), shall be well-formed.</para><para>Precondition: this shall be the active <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref>.</para><para>Postconditions: A call to run may return on a different thread than that on which it was called.</para><para><simplesect kind="note"><para>The call to <emphasis>run</emphasis> is sequenced before the continuation as if <emphasis>run</emphasis> returns on the same thread. The invocation of the user-supplied callable object f may be immediate or may be delayed until compute resources are available. <emphasis>run</emphasis> might or might not return before invocation of f completes.</para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>This</parametername>
</parameternamelist>
<parameterdescription>
<para>function may throw <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__canceled__exception" kindref="compound">task_canceled_exception</ref></emphasis>, as described in Exception Handling. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="299" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="299" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a409b3ac4d95c5f22eaf49a1012d26200" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::parallel::v2::task_block&lt; ExPolicy &gt;::wait</definition>
        <argsstring>()</argsstring>
        <name>wait</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Blocks until the tasks spawned using this <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> have finished.</para><para>Precondition: this shall be the active <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref>.</para><para>Postcondition: All tasks spawned by the nearest enclosing task region have finished. A call to wait may return on a different thread than that on which it was called.</para><para><simplesect kind="note"><para>The call to <emphasis>wait</emphasis> is sequenced before the continuation as if <emphasis>wait</emphasis> returns on the same thread.</para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>This</parametername>
</parameternamelist>
<parameterdescription>
<para>function may throw <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__canceled__exception" kindref="compound">task_canceled_exception</ref></emphasis>, as described in Exception Handling.</para></parameterdescription>
</parameteritem>
</parameterlist>
<programlisting><codeline><highlight class="normal">Example:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>define_task_block([&amp;](auto&amp;<sp/>tr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tr.run([&amp;]{<sp/>process(a,<sp/>w,<sp/>x);<sp/>});<sp/>//<sp/>Process<sp/>a[w]<sp/>through<sp/>a[x]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(y<sp/>&lt;<sp/>x)<sp/>tr.wait();<sp/><sp/><sp/>//<sp/>Wait<sp/>if<sp/>overlap<sp/>between<sp/>[w,<sp/>x)<sp/>and<sp/>[y,<sp/>z)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>process(a,<sp/>y,<sp/>z);<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Process<sp/>a[y]<sp/>through<sp/>a[z]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="343" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="343" bodyend="355"/>
      </memberdef>
      <memberdef kind="function" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a1e54dbb3c28c991b928548366f500455" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>ExPolicy &amp;</type>
        <definition>ExPolicy&amp; hpx::parallel::v2::task_block&lt; ExPolicy &gt;::policy</definition>
        <argsstring>()</argsstring>
        <name>policy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a reference to the execution policy used to construct this object.</para><para>Precondition: this shall be the active <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="362" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="362" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a3a481461d7f33eff0c9b6df4bb093593" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>ExPolicy const  &amp;</type>
        <definition>ExPolicy const&amp; hpx::parallel::v2::task_block&lt; ExPolicy &gt;::policy</definition>
        <argsstring>() const</argsstring>
        <name>policy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a reference to the execution policy used to construct this object.</para><para>Precondition: this shall be the active <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/parallel/task_block.hpp" line="369" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="369" bodyend="369"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>The class <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> defines an interface for forking and joining parallel tasks. The <emphasis>define_task_block</emphasis> and <emphasis>define_task_block_restore_thread</emphasis> function templates create an object of type <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> and pass a reference to that object to a user-provided callable object.</para><para>An object of class <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis> cannot be constructed, destroyed, copied, or moved except by the implementation of the task region library. Taking the address of a <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> object via operator&amp; or addressof is ill formed. The result of obtaining its address by any other means is unspecified.</para><para>A <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis> is active if it was created by the nearest enclosing task block, where &quot;task block&quot; refers to an invocation of define_task_block or define_task_block_restore_thread and &quot;nearest
enclosing&quot; means the most recent invocation that has not yet completed. Code designated for execution in another thread by means other than the facilities in this section (e.g., using thread or async) are not enclosed in the task region and a <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> passed to (or captured by) such code is not active within that code. Performing any operation on a <ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref> that is not active results in undefined behavior.</para><para>The <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis> that is active before a specific call to the run member function is not active within the asynchronous function that invoked run. (The invoked function should not, therefore, capture the <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis> from the surrounding block.)</para><para><programlisting><codeline><highlight class="normal">Example:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>define_task_block([&amp;](auto&amp;<sp/>tr)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tr.run([&amp;]<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tr.run([]<sp/>{<sp/>f();<sp/>});<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Error:<sp/>tr<sp/>is<sp/>not<sp/>active</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>define_task_block([&amp;](auto&amp;<sp/>tr)<sp/>{<sp/><sp/><sp/>//<sp/>Nested<sp/>task<sp/>block</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tr.run(f);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>OK:<sp/>inner<sp/>tr<sp/>is<sp/>active</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
</programlisting></para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy an instance of a <emphasis><ref refid="classhpx_1_1parallel_1_1v2_1_1task__block" kindref="compound">task_block</ref></emphasis> was created with. This defaults to <emphasis>parallel_policy</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>    </detaileddescription>
    <location file="hpx/parallel/task_block.hpp" line="117" column="1" bodyfile="hpx/parallel/task_block.hpp" bodystart="116" bodyend="377"/>
    <listofallmembers>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a01521453dc95bf19d361bd99e2d0c4aa" prot="private" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>errors_</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1aab56ea8bdf25594112ccab9889c3e294" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>execution_policy</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1ac6a81aa62ea26bd2b790b573af04bac6" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>get_execution_policy</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a3ac0cb819cb10fa1847d8207228b81ba" prot="private" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>id_</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a7b2dc2eea923d591eb814e432ec597b2" prot="private" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>mtx_</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a1e54dbb3c28c991b928548366f500455" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>policy</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a3a481461d7f33eff0c9b6df4bb093593" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>policy</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a4cbbea8135c1507e713de14d0e8be80b" prot="private" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>policy_</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a942ef260b49d3bd93b3f63df973b577b" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>run</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1ad19e4cb24036c2adbd421cec62926821" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>run</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1acf5200a8cf8e8866fcd5885c2de4cfe6" prot="private" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>tasks_</name></member>
      <member refid="classhpx_1_1parallel_1_1v2_1_1task__block_1a409b3ac4d95c5f22eaf49a1012d26200" prot="public" virt="non-virtual"><scope>hpx::parallel::v2::task_block</scope><name>wait</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
