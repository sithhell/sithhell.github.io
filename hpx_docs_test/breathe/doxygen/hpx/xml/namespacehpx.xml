<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacehpx" kind="namespace" language="C++">
    <compoundname>hpx</compoundname>
    <innerclass refid="structhpx_1_1launch" prot="public">hpx::launch</innerclass>
    <innerclass refid="structhpx_1_1when__any__result" prot="public">hpx::when_any_result</innerclass>
    <innerclass refid="structhpx_1_1when__some__result" prot="public">hpx::when_some_result</innerclass>
    <innernamespace refid="namespacehpx_1_1actions">hpx::actions</innernamespace>
    <innernamespace refid="namespacehpx_1_1applier">hpx::applier</innernamespace>
    <innernamespace refid="namespacehpx_1_1components">hpx::components</innernamespace>
    <innernamespace refid="namespacehpx_1_1lcos">hpx::lcos</innernamespace>
    <innernamespace refid="namespacehpx_1_1naming">hpx::naming</innernamespace>
    <innernamespace refid="namespacehpx_1_1parallel">hpx::parallel</innernamespace>
    <innernamespace refid="namespacehpx_1_1performance__counters">hpx::performance_counters</innernamespace>
    <innernamespace refid="namespacehpx_1_1resource">hpx::resource</innernamespace>
    <innernamespace refid="namespacehpx_1_1this__thread">hpx::this_thread</innernamespace>
    <innernamespace refid="namespacehpx_1_1threads">hpx::threads</innernamespace>
    <innernamespace refid="namespacehpx_1_1traits">hpx::traits</innernamespace>
    <innernamespace refid="namespacehpx_1_1util">hpx::util</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" prot="public" static="no">
        <name>runtime_mode</name>
        <enumvalue id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bfa0f1143f7bb8e783a8efde8201b65bf79" prot="public">
          <name>runtime_mode_invalid</name>
          <initializer>= -1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b" prot="public">
          <name>runtime_mode_console</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>The runtime is the console locality. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e" prot="public">
          <name>runtime_mode_worker</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>The runtime is a worker locality. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bfaf09a99c3187af6c1ae86efe086b90bd6" prot="public">
          <name>runtime_mode_connect</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The runtime is a worker locality connecting late </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bfabdc3faac1dd0c8df0fbb2937792aa895" prot="public">
          <name>runtime_mode_default</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>The runtime mode will be determined based on the command line arguments </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bfaabb25708024e48b832b635adfa552f37" prot="public">
          <name>runtime_mode_last</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A HPX runtime can be executed in two different modes: console mode and worker mode. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/runtime_mode.hpp" line="21" column="1" bodyfile="hpx/runtime/runtime_mode.hpp" bodystart="20" bodyend="30"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="set__parcel__write__handler_8hpp_1ab95e97c81bfae24a79e4d0f2956f0fe1" prot="public" static="no">
        <type>util::function_nonser&lt; void(boost::system::error_code const  &amp;, parcelset::parcel const  &amp;) &gt;</type>
        <definition>typedef util::function_nonser&lt; void(boost::system::error_code const&amp;, parcelset::parcel const&amp;) &gt; hpx::parcel_write_handler_type</definition>
        <argsstring></argsstring>
        <name>parcel_write_handler_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The type of a function which can be registered as a parcel write handler using the function <emphasis>hpx::set_parcel_write_handler</emphasis>.</para><para><simplesect kind="note"><para>A parcel write handler is a function which is called by the parcel layer whenever a parcel has been sent by the underlying networking library and if no explicit parcel handler function was specified for the parcel. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/set_parcel_write_handler.hpp" line="27" column="1" bodyfile="hpx/runtime/set_parcel_write_handler.hpp" bodystart="27" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="shutdown__function_8hpp_1a1f43ecb2f7750d274e512fefc25ae059" prot="public" static="no">
        <type>util::unique_function_nonser&lt; void()&gt;</type>
        <definition>typedef util::unique_function_nonser&lt;void()&gt; hpx::shutdown_function_type</definition>
        <argsstring></argsstring>
        <name>shutdown_function_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The type of a function which is registered to be executed as a shutdown or pre-shutdown function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/shutdown_function.hpp" line="19" column="1" bodyfile="hpx/runtime/shutdown_function.hpp" bodystart="19" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" prot="public" static="no">
        <type>util::unique_function_nonser&lt; void()&gt;</type>
        <definition>typedef util::unique_function_nonser&lt;void()&gt; hpx::startup_function_type</definition>
        <argsstring></argsstring>
        <name>startup_function_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The type of a function which is registered to be executed as a startup or pre-startup function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/startup_function.hpp" line="20" column="1" bodyfile="hpx/runtime/startup_function.hpp" bodystart="20" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="hpx__init_8hpp_1a5e6a525da6bd737bce5a5800b50ba322" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(util::function_nonser&lt; int(hpx::program_options::variables_map &amp;vm) &gt; const &amp;f, hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>util::function_nonser&lt; int(hpx::program_options::variables_map &amp;vm) &gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is the main entry point for any HPX application. This function (or one of its overloads below) should be called from the users <computeroutput>main()</computeroutput> function. It will set up the HPX runtime environment and schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="116" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a0c889be6b1d335477fb4b15d740707e9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(int(*f)(hpx::program_options::variables_map &amp;vm), hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>int(*)(hpx::program_options::variables_map &amp;vm)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is the main entry point for any HPX application. This function (or one of its overloads below) should be called from the users <computeroutput>main()</computeroutput> function. It will set up the HPX runtime environment and schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="176" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a2b4ffe8d5744350696d913e77a7985ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="230" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1ab27d8128032253c28b9fbc72440a7e60" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="289" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1abda8ebec19e8632bb987536ceab59ce7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="333" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a449cc915f97c2e04f014236e6f8bcb90" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, hpx::runtime_mode mode)</argsstring>
        <name>init</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="376" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a28cafe08e2cde191ce8fe905691e9196" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode)</argsstring>
        <name>init</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="425" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1adebf2eae88a87022dbc5bacf619e22a3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(std::string const &amp;app_name, int argc=0, char **argv=nullptr, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>app_name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>app_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The name of the application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="459" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a13cd8a7a3209ffbc5a237f121a46eb49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(int argc=0, char **argv=nullptr, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. If not command line arguments are passed, console mode is assumed.</para></simplesect>
<simplesect kind="note"><para>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section &apos;HPX Command Line Options&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="500" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a462c73b02f8f393597d7149b6d2a6390" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from <computeroutput>hpx_main</computeroutput> (or 0 when executed in worker mode).</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. If not command line arguments are passed, console mode is assumed.</para></simplesect>
<simplesect kind="note"><para>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section &apos;HPX Command Line Options&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="538" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a182c85fa1415763ac4d5175356691d04" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(int(*f)(hpx::program_options::variables_map &amp;vm), std::string const &amp;app_name, int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>int(*)(hpx::program_options::variables_map &amp;vm)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>app_name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>app_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The name of the application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied function <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="576" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a7df3cdeb0b4259e1e7a7bf4ddcdfae4e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(int(*f)(hpx::program_options::variables_map &amp;vm), int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>int(*)(hpx::program_options::variables_map &amp;vm)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied function <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="614" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a7dbf92ae7898899431df5fff333c4240" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(util::function_nonser&lt; int(int, char **)&gt; const &amp;f, std::string const &amp;app_name, int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>util::function_nonser&lt; int(int, char **)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>app_name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>app_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The name of the application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied function <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="652" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1a30828fd4ee776cd069196712c5719434" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(util::function_nonser&lt; int(int, char **)&gt; const &amp;f, int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>util::function_nonser&lt; int(int, char **)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied function <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="690" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__init_8hpp_1ac5c94e7a4250674e36082626aa34f3fc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::init</definition>
        <argsstring>(util::function_nonser&lt; int(int, char **)&gt; const &amp;f, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>init</name>
        <param>
          <type>util::function_nonser&lt; int(int, char **)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied function <computeroutput>f</computeroutput>.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_init.hpp" line="733" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1aa5fa036bb6f8407c5e4341836122115d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(util::function_nonser&lt; int(hpx::program_options::variables_map &amp;vm)&gt; const &amp;f, hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>util::function_nonser&lt; int(hpx::program_options::variables_map &amp;vm)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is the main, non-blocking entry point for any HPX application. This function (or one of its overloads below) should be called from the users <computeroutput>main()</computeroutput> function. It will set up the HPX runtime environment and schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="110" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a2bc2fb2006f6cc57e33a691bdf92699c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(int(*f)(hpx::program_options::variables_map &amp;vm), hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>int(*)(hpx::program_options::variables_map &amp;vm)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is the main, non-blocking entry point for any HPX application. This function (or one of its overloads below) should be called from the users <computeroutput>main()</computeroutput> function. It will set up the HPX runtime environment and schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="171" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1ab56e1847d1aa9f757f3c186c0ee29611" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="227" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1ad34fd8fbeb934f34992945cf7ce97155" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, startup_function_type startup=startup_function_type(), shutdown_function_type shutdown=shutdown_function_type(), hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>startup</declname>
          <defval><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref>()</defval>
        </param>
        <param>
          <type>shutdown_function_type</type>
          <declname>shutdown</declname>
          <defval>shutdown_function_type()</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>startup</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside a HPX thread before <computeroutput>f</computeroutput> is called. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shutdown</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A function to be executed inside an HPX thread while hpx::finalize is executed. If this parameter is not given no function will be executed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="288" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a61e01ea3c0e0eed0f30ac3eecb58f4f7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="337" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1aaf85652e50bb86519c6f26d1b8d534ac" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, hpx::runtime_mode mode)</argsstring>
        <name>start</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="382" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a0b5cd78115c9bf956c94094a51ff2760" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(hpx::program_options::options_description const &amp;desc_cmdline, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode)</argsstring>
        <name>start</name>
        <param>
          <type>hpx::program_options::options_description const &amp;</type>
          <declname>desc_cmdline</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para>In console mode it will execute the user supplied function <computeroutput>hpx_main</computeroutput>, in worker mode it will execute an empty <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>desc_cmdline</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <emphasis>hpx::init</emphasis> (see description below). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>If the parameter <computeroutput>mode</computeroutput> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. Otherwise it will be executed as specified by the parameter<computeroutput>mode</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="433" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a9ddc6ea9a1a6faa5aff2a7c723752591" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(std::string const &amp;app_name, int argc=0, char **argv=nullptr, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>app_name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>app_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The name of the application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="469" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a5ee710f0fe99def75e0ef2f5ee1ab94e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(int argc=0, char **argv=nullptr, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. If not command line arguments are passed, console mode is assumed.</para></simplesect>
<simplesect kind="note"><para>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section &apos;HPX Command Line Options&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="509" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a6b072b4e453f66c127d9b8108cfc3485" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. If not command line arguments are passed, console mode is assumed.</para></simplesect>
<simplesect kind="note"><para>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section &apos;HPX Command Line Options&apos;. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="549" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a352309b32d4b199763a46bf9469bdba7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(int(*f)(hpx::program_options::variables_map &amp;vm), std::string const &amp;app_name, int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>int(*)(hpx::program_options::variables_map &amp;vm)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>app_name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>app_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The name of the application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="588" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a7c75886f31b64226b848655fc69bf611" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(util::function_nonser&lt; int(int, char **)&gt; const &amp;f, std::string const &amp;app_name, int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>util::function_nonser&lt; int(int, char **)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>app_name</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>app_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The name of the application. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="630" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a872343d36e0fe7f79e76ea6def83d39e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(int(*f)(hpx::program_options::variables_map &amp;vm), int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>int(*)(hpx::program_options::variables_map &amp;vm)</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="671" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1a8d56659a465baf2303c2b88936e7cf0e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(util::function_nonser&lt; int(int, char **)&gt; const &amp;f, int argc, char **argv, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>util::function_nonser&lt; int(int, char **)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="711" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__start_8hpp_1ac448add81d30e8932cd3a4ce367de66e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::start</definition>
        <argsstring>(util::function_nonser&lt; int(int, char **)&gt; const &amp;f, int argc, char **argv, std::vector&lt; std::string &gt; const &amp;cfg, hpx::runtime_mode mode=hpx::runtime_mode_default)</argsstring>
        <name>start</name>
        <param>
          <type>util::function_nonser&lt; int(int, char **)&gt; const &amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>std::vector&lt; std::string &gt; const &amp;</type>
          <declname>cfg</declname>
        </param>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">hpx::runtime_mode</ref></type>
          <declname>mode</declname>
          <defval>hpx::runtime_mode_default</defval>
        </param>
        <briefdescription>
<para>Main non-blocking entry point for launching the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <computeroutput>hpx::wait</computeroutput> and <computeroutput>hpx::stop</computeroutput> to synchronize with the runtime system&apos;s execution. This overload will schedule the function given by <computeroutput>f</computeroutput> as a HPX thread. It will not call <computeroutput>hpx_main</computeroutput>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <computeroutput>f</computeroutput> is <computeroutput>nullptr</computeroutput> the HPX runtime environment will be started without invoking <computeroutput>f</computeroutput>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argc</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of command line arguments passed in <computeroutput>argv</computeroutput>. This is usually the unchanged value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>argv</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The command line arguments for this application, usually that is the value as passed by the operating system (to <computeroutput>main()</computeroutput>). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cfg</parametername>
</parameternamelist>
<parameterdescription>
<para>A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance &apos;hpx.component.enabled=1&apos;) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<emphasis>hpx::runtime_mode_console</emphasis>), all other localities have to be run in worker mode (<emphasis>hpx::runtime_mode_worker</emphasis>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns <emphasis>true</emphasis> if command line processing succeeded and the runtime system was started successfully. It will return <emphasis>false</emphasis> otherwise.</para></simplesect>
<simplesect kind="note"><para>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <computeroutput>argc</computeroutput>/<computeroutput>argv</computeroutput>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_start.hpp" line="757" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__finalize_8hpp_1ab7eb159cb77997b366b5d79e65f04cd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::finalize</definition>
        <argsstring>(double shutdown_timeout, double localwait=-1.0, error_code &amp;ec=throws)</argsstring>
        <name>finalize</name>
        <param>
          <type>double</type>
          <declname>shutdown_timeout</declname>
        </param>
        <param>
          <type>double</type>
          <declname>localwait</declname>
          <defval>-1.0</defval>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Main function to gracefully terminate the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::finalize</emphasis> is the main way to (gracefully) exit any HPX application. It should be called from one locality only (usually the console) and it will notify all connected localities to finish execution. Only after all other localities have exited this function will return, allowing to exit the console locality as well.</para><para>During the execution of this function the runtime system will invoke all registered shutdown functions (see <emphasis>hpx::init</emphasis>) on all localities.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shutdown_timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>This parameter allows to specify a timeout (in microseconds), specifying how long any of the connected localities should wait for pending tasks to be executed. After this timeout, all suspended HPX-threads will be aborted. Note, that this function will not abort any running HPX-threads. In any case the shutdown will not proceed as long as there is at least one pending/running HPX-thread.</para></parameterdescription>
</parameteritem>
</parameterlist>
The default value (<computeroutput>-1.0</computeroutput>) will try to find a globally set timeout value (can be set as the configuration parameter <computeroutput>hpx.shutdown_timeout</computeroutput>), and if that is not set or <computeroutput>-1.0</computeroutput> as well, it will disable any timeout, each connected locality will wait for all existing HPX-threads to terminate.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>localwait</parametername>
</parameternamelist>
<parameterdescription>
<para>This parameter allows to specify a local wait time (in microseconds) before the connected localities will be notified and the overall shutdown process starts.</para></parameterdescription>
</parameteritem>
</parameterlist>
The default value (<computeroutput>-1.0</computeroutput>) will try to find a globally set wait time value (can be set as the configuration parameter &quot;hpx.finalize_wait_time&quot;), and if this is not set or <computeroutput>-1.0</computeroutput> as well, it will disable any addition local wait time before proceeding.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function will always return zero.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
This function will block and wait for all connected localities to exit before returning to the caller. It should be the last HPX-function called by any application.</para><para>Using this function is an alternative to <emphasis>hpx::disconnect</emphasis>, these functions do not need to be called both. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_finalize.hpp" line="69" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__finalize_8hpp_1adadfe0973783fa126afca52feda59529" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::finalize</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>finalize</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Main function to gracefully terminate the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::finalize</emphasis> is the main way to (gracefully) exit any HPX application. It should be called from one locality only (usually the console) and it will notify all connected localities to finish execution. Only after all other localities have exited this function will return, allowing to exit the console locality as well.</para><para>During the execution of this function the runtime system will invoke all registered shutdown functions (see <emphasis>hpx::init</emphasis>) on all localities.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function will always return zero.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
This function will block and wait for all connected localities to exit before returning to the caller. It should be the last HPX-function called by any application.</para><para>Using this function is an alternative to <emphasis>hpx::disconnect</emphasis>, these functions do not need to be called both. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_finalize.hpp" line="100" column="1" bodyfile="hpx/hpx_finalize.hpp" bodystart="100" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="hpx__finalize_8hpp_1a460472f748021ade829cca393930d1a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>HPX_NORETURN void</type>
        <definition>HPX_NORETURN void hpx::terminate</definition>
        <argsstring>()</argsstring>
        <name>terminate</name>
        <briefdescription>
<para>Terminate any application non-gracefully. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::terminate</emphasis> is the non-graceful way to exit any application immediately. It can be called from any locality and will terminate all localities currently used by the application.</para><para><simplesect kind="note"><para>This function will cause HPX to call <computeroutput><ref refid="hpx__finalize_8hpp_1a460472f748021ade829cca393930d1a2" kindref="member">std::terminate()</ref></computeroutput> on all localities associated with this application. If the function is called not from an HPX thread it will fail and return an error using the argument <emphasis>ec</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_finalize.hpp" line="115" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__finalize_8hpp_1a33db29f916f1591d6b37c6b6d76886d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::disconnect</definition>
        <argsstring>(double shutdown_timeout, double localwait=-1.0, error_code &amp;ec=throws)</argsstring>
        <name>disconnect</name>
        <param>
          <type>double</type>
          <declname>shutdown_timeout</declname>
        </param>
        <param>
          <type>double</type>
          <declname>localwait</declname>
          <defval>-1.0</defval>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Disconnect this locality from the application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::disconnect</emphasis> can be used to disconnect a locality from a running HPX application.</para><para>During the execution of this function the runtime system will invoke all registered shutdown functions (see <emphasis>hpx::init</emphasis>) on this locality. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shutdown_timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>This parameter allows to specify a timeout (in microseconds), specifying how long this locality should wait for pending tasks to be executed. After this timeout, all suspended HPX-threads will be aborted. Note, that this function will not abort any running HPX-threads. In any case the shutdown will not proceed as long as there is at least one pending/running HPX-thread.</para></parameterdescription>
</parameteritem>
</parameterlist>
The default value (<computeroutput>-1.0</computeroutput>) will try to find a globally set timeout value (can be set as the configuration parameter &quot;hpx.shutdown_timeout&quot;), and if that is not set or <computeroutput>-1.0</computeroutput> as well, it will disable any timeout, each connected locality will wait for all existing HPX-threads to terminate.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>localwait</parametername>
</parameternamelist>
<parameterdescription>
<para>This parameter allows to specify a local wait time (in microseconds) before the connected localities will be notified and the overall shutdown process starts.</para></parameterdescription>
</parameteritem>
</parameterlist>
The default value (<computeroutput>-1.0</computeroutput>) will try to find a globally set wait time value (can be set as the configuration parameter <computeroutput>hpx.finalize_wait_time</computeroutput>), and if this is not set or <computeroutput>-1.0</computeroutput> as well, it will disable any addition local wait time before proceeding.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function will always return zero.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
This function will block and wait for this locality to finish executing before returning to the caller. It should be the last HPX-function called by any locality being disconnected. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_finalize.hpp" line="164" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__finalize_8hpp_1ad05607f97e7977530074039d29ca0512" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::disconnect</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>disconnect</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Disconnect this locality from the application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::disconnect</emphasis> can be used to disconnect a locality from a running HPX application.</para><para>During the execution of this function the runtime system will invoke all registered shutdown functions (see <emphasis>hpx::init</emphasis>) on this locality.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function will always return zero.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
This function will block and wait for this locality to finish executing before returning to the caller. It should be the last HPX-function called by any locality being disconnected. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_finalize.hpp" line="190" column="1" bodyfile="hpx/hpx_finalize.hpp" bodystart="190" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="hpx__finalize_8hpp_1a1b4c2c4851fcae7c6c01617b6181d44f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::stop</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>stop</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Stop the runtime system. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The function returns the value, which has been returned from the user supplied main HPX function (usually <computeroutput>hpx_main</computeroutput>).</para></simplesect>
This function will block and wait for this locality to finish executing before returning to the caller. It should be the last HPX-function called on every locality. This function should be used only if the runtime system was started using <computeroutput>hpx::start</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_finalize.hpp" line="206" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__suspend_8hpp_1a2c7789229c2d816106262236343586a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::suspend</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>suspend</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Suspend the runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::suspend</emphasis> is used to suspend the HPX runtime system. It can only be used when running HPX on a single locality. It will block waiting for all thread pools to be empty. This function only be called when the runtime is running, or already suspended in which case this function will do nothing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function will always return zero.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_suspend.hpp" line="34" column="1"/>
      </memberdef>
      <memberdef kind="function" id="hpx__suspend_8hpp_1a2705fd1033c1d6a011ba0c42ff39a7ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hpx::resume</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>resume</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Resume the HPX runtime system. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>hpx::resume</emphasis> is used to resume the HPX runtime system. It can only be used when running HPX on a single locality. It will block waiting for all thread pools to be resumed. This function only be called when the runtime suspended, or already running in which case this function will do nothing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function will always return zero.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/hpx_suspend.hpp" line="54" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a0bdf7871dfff58e68ae5eab9af23f2aa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::register_thread</definition>
        <argsstring>(runtime *rt, char const *name, error_code &amp;ec=throws)</argsstring>
        <name>register_thread</name>
        <param>
          <type>runtime *</type>
          <declname>rt</declname>
        </param>
        <param>
          <type>char const *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register the current kernel thread with HPX, this should be done once for each external OS-thread intended to invoke HPX functionality. Calling this function more than once will silently fail. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="43" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1ae6fab9f567417d9f1fa0772537b5dc2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::unregister_thread</definition>
        <argsstring>(runtime *rt)</argsstring>
        <name>unregister_thread</name>
        <param>
          <type>runtime *</type>
          <declname>rt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Unregister the thread from HPX, this should be done once in the end before the external thread exists. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="48" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a20392fc425de279eb5ef5f0206825d26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>naming::gid_type const  &amp;</type>
        <definition>naming::gid_type const&amp; hpx::get_locality</definition>
        <argsstring>()</argsstring>
        <name>get_locality</name>
        <briefdescription>
<para>The function <emphasis>get_locality</emphasis> returns a reference to the locality prefix. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="51" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a9cd8c96309c6ea084c51856ae6cde7a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t hpx::get_runtime_instance_number</definition>
        <argsstring>()</argsstring>
        <name>get_runtime_instance_number</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>get_runtime_instance_number</emphasis> returns a unique number associated with the runtime instance the current thread is running in. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1ab6a4104504c101248834fe490c813b08" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::register_on_exit</definition>
        <argsstring>(util::function_nonser&lt; void()&gt; const &amp;)</argsstring>
        <name>register_on_exit</name>
        <param>
          <type>util::function_nonser&lt; void()&gt; const &amp;</type>
        </param>
        <briefdescription>
<para>Register a function to be called during system shutdown. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="58" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1ad8fbe89e273b0a5d2f57ea09a971e1af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::is_starting</definition>
        <argsstring>()</argsstring>
        <name>is_starting</name>
        <briefdescription>
<para>Test whether the runtime system is currently being started. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns whether the runtime system is currently being started or not, e.g. whether the current state of the runtime system is <emphasis>hpx::state_startup</emphasis> </para><para><simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will return false otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="93" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a6a7e3387e6a55d6d7040a142bda044d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::tolerate_node_faults</definition>
        <argsstring>()</argsstring>
        <name>tolerate_node_faults</name>
        <briefdescription>
<para>Test if HPX runs in fault-tolerant mode. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns whether the runtime system is running in fault-tolerant mode </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="101" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1ab20f0913801d5a05d84e4eac0e24f704" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::is_running</definition>
        <argsstring>()</argsstring>
        <name>is_running</name>
        <briefdescription>
<para>Test whether the runtime system is currently running. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns whether the runtime system is currently running or not, e.g. whether the current state of the runtime system is <emphasis>hpx::state_running</emphasis> </para><para><simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will return false otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="112" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a04f7638724843ab606835ba07816acb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::is_stopped</definition>
        <argsstring>()</argsstring>
        <name>is_stopped</name>
        <briefdescription>
<para>Test whether the runtime system is currently stopped. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns whether the runtime system is currently stopped or not, e.g. whether the current state of the runtime system is <emphasis>hpx::state_stopped</emphasis> </para><para><simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will return false otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="123" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a6ed14cb2616c96933836462c355f1e13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool hpx::is_stopped_or_shutting_down</definition>
        <argsstring>()</argsstring>
        <name>is_stopped_or_shutting_down</name>
        <briefdescription>
<para>Test whether the runtime system is currently being shut down. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns whether the runtime system is currently being shut down or not, e.g. whether the current state of the runtime system is <emphasis>hpx::state_stopped</emphasis> or <emphasis>hpx::state_shutdown</emphasis> </para><para><simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will return false otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="134" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1ae0cb050327ed37e6863061bd1761409e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t hpx::get_num_worker_threads</definition>
        <argsstring>()</argsstring>
        <name>get_num_worker_threads</name>
        <briefdescription>
<para>Return the number of worker OS- threads used to execute HPX threads. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the number of OS-threads used to execute HPX threads. If the function is called while no HPX runtime system is active, it will return zero. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="143" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a805a6863e2633550de10e42233f6ee0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint64_t</type>
        <definition>std::uint64_t hpx::get_system_uptime</definition>
        <argsstring>()</argsstring>
        <name>get_system_uptime</name>
        <briefdescription>
<para>Return the system uptime measure on the thread executing this call. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the system uptime measured in nanoseconds for the thread executing this call. If the function is called while no HPX runtime system is active, it will return zero. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="151" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a63bda005cda88c7c7e42a29e950176f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::start_active_counters</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>start_active_counters</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Start all active performance counters, optionally naming the section of code. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>The active counters are those which have been specified on the command line while executing the application (see command line option --hpx:print-counter) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="169" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1ad3c6bed4bad130ad9b104b7f4a55b4ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::reset_active_counters</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>reset_active_counters</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Resets all active performance counters. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>The active counters are those which have been specified on the command line while executing the application (see command line option --hpx:print-counter) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="185" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a60e4928d4f5e31bed41b45e3d0e61b56" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::reinit_active_counters</definition>
        <argsstring>(bool reset=true, error_code &amp;ec=throws)</argsstring>
        <name>reinit_active_counters</name>
        <param>
          <type>bool</type>
          <declname>reset</declname>
          <defval>true</defval>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Re-initialize all active performance counters. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reset</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Reset the current values before re-initializing counters (default: true) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>The active counters are those which have been specified on the command line while executing the application (see command line option --hpx:print-counter) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="203" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a32ecc3b6052e3801ab35b11cdbcdaccd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::stop_active_counters</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>stop_active_counters</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Stop all active performance counters. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>The active counters are those which have been specified on the command line while executing the application (see command line option --hpx:print-counter) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="220" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a321a5315c52ed45b3d2fc64599c3f898" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::evaluate_active_counters</definition>
        <argsstring>(bool reset=false, char const *description=nullptr, error_code &amp;ec=throws)</argsstring>
        <name>evaluate_active_counters</name>
        <param>
          <type>bool</type>
          <declname>reset</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>char const *</type>
          <declname>description</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Evaluate and output all active performance counters, optionally naming the point in code marked by this function. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>reset</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] this is an optional flag allowing to reset the counter value after it has been evaluated. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>description</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] this is an optional value naming the point in the code marked by the call to this function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>The output generated by this function is redirected to the destination specified by the corresponding command line options (see --hpx:print-counter-destination).</para></simplesect>
<simplesect kind="note"><para>The active counters are those which have been specified on the command line while executing the application (see command line option --hpx:print-counter) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="245" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__fwd_8hpp_1a68b368379e3bfb318c7cbe5928dbd4e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>serialization::binary_filter *</type>
        <definition>serialization::binary_filter* hpx::create_binary_filter</definition>
        <argsstring>(char const *binary_filter_type, bool compress, serialization::binary_filter *next_filter=nullptr, error_code &amp;ec=throws)</argsstring>
        <name>create_binary_filter</name>
        <param>
          <type>char const *</type>
          <declname>binary_filter_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>compress</declname>
        </param>
        <param>
          <type>serialization::binary_filter *</type>
          <declname>next_filter</declname>
          <defval>nullptr</defval>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Create an instance of a binary filter plugin. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>binary_filter_type</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The type of the binary filter to create </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>compress</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The created filter should support compression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>next_filter</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Use this as the filter to dispatch the invocation into. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime_fwd.hpp" line="263" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1a66926bac762addf6d636fdb2cf148516" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; hpx::future&lt; hpx::id_type &gt; &gt;</type>
        <definition>std::vector&lt; Client &gt; hpx::find_all_from_basename</definition>
        <argsstring>(std::string base_name, std::size_t num_ids)</argsstring>
        <name>find_all_from_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>num_ids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return all registered ids from all localities from the given base name.</para><para>This function locates all ids which were registered with the given base name. It returns a list of futures representing those ids.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_ids</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of registered ids to expect.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A list of futures representing the ids which were registered using the given base name.</para></simplesect>
<simplesect kind="note"><para>The futures will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered.</para></simplesect>
Return all registered clients from all localities from the given base name.</para><para>This function locates all ids which were registered with the given base name. It returns a list of futures representing those ids.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Client</parametername>
</parameternamelist>
<parameterdescription>
<para>The client type to return</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_ids</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of registered ids to expect.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A list of futures representing the ids which were registered using the given base name.</para></simplesect>
<simplesect kind="note"><para>The futures embedded in the returned client objects will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="53" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1aab131e9a24c4a1a9bc04dca4f45d675b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; hpx::future&lt; hpx::id_type &gt; &gt;</type>
        <definition>std::vector&lt; Client &gt; hpx::find_from_basename</definition>
        <argsstring>(std::string base_name, std::vector&lt; std::size_t &gt; const &amp;ids)</argsstring>
        <name>find_from_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>std::vector&lt; std::size_t &gt; const &amp;</type>
          <declname>ids</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return registered ids from the given base name and sequence numbers.</para><para>This function locates the ids which were registered with the given base name and the given sequence numbers. It returns a list of futures representing those ids.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ids</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The sequence numbers of the registered ids.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A list of futures representing the ids which were registered using the given base name and sequence numbers.</para></simplesect>
<simplesect kind="note"><para>The futures will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered.</para></simplesect>
Return registered clients from the given base name and sequence numbers.</para><para>This function locates the ids which were registered with the given base name and the given sequence numbers. It returns a list of futures representing those ids.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Client</parametername>
</parameternamelist>
<parameterdescription>
<para>The client type to return</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ids</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The sequence numbers of the registered ids.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A list of futures representing the ids which were registered using the given base name and sequence numbers.</para></simplesect>
<simplesect kind="note"><para>The futures embedded in the returned client objects will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="99" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1adb273a4ba592836bba34943a3674aec5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>hpx::future&lt; hpx::id_type &gt;</type>
        <definition>Client hpx::find_from_basename</definition>
        <argsstring>(std::string base_name, std::size_t sequence_nr=~0U)</argsstring>
        <name>find_from_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>sequence_nr</declname>
          <defval>~0U</defval>
        </param>
        <briefdescription>
<para>Return registered id from the given base name and sequence number. </para>        </briefdescription>
        <detaileddescription>
<para>This function locates the id which was registered with the given base name and the given sequence number. It returns a future representing those id.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The sequence number of the registered id.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A representing the id which was registered using the given base name and sequence numbers.</para></simplesect>
<simplesect kind="note"><para>The future will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered.</para></simplesect>
This function locates the id which was registered with the given base name and the given sequence number. It returns a future representing those id.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Client</parametername>
</parameternamelist>
<parameterdescription>
<para>The client type to return</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The sequence number of the registered id.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A representing the id which was registered using the given base name and sequence numbers.</para></simplesect>
<simplesect kind="note"><para>The future embedded in the returned client object will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="145" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1ab07858717ce3212089fabddc841239e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>hpx::future&lt; bool &gt;</type>
        <definition>hpx::future&lt;bool&gt; hpx::register_with_basename</definition>
        <argsstring>(std::string base_name, hpx::id_type id, std::size_t sequence_nr=~0U)</argsstring>
        <name>register_with_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>hpx::id_type</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>sequence_nr</declname>
          <defval>~0U</defval>
        </param>
        <briefdescription>
<para>Register the given id using the given base name. </para>        </briefdescription>
        <detaileddescription>
<para>The function registers the given ids using the provided base name.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The id to register using the given base name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in, optional] The sequential number to use for the registration of the id. This number has to be unique system wide for each registration using the same base name. The default is the current locality identifier. Also, the sequence numbers have to be consecutive starting from zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future representing the result of the registration operation itself.</para></simplesect>
<simplesect kind="note"><para>The operation will fail if the given sequence number is not unique. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="194" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1a5c7e5ae41d3ba06633d53c18c2f92978" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>hpx::future&lt; bool &gt;</type>
        <definition>hpx::future&lt;bool&gt; hpx::register_with_basename</definition>
        <argsstring>(std::string base_name, hpx::future&lt; hpx::id_type &gt; f, std::size_t sequence_nr=~0U)</argsstring>
        <name>register_with_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>hpx::future&lt; hpx::id_type &gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>sequence_nr</declname>
          <defval>~0U</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register the id wrapped in the given future using the given base name.</para><para>The function registers the object the given future refers to using the provided base name.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The future which should be registered using the given base name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in, optional] The sequential number to use for the registration of the id. This number has to be unique system wide for each registration using the same base name. The default is the current locality identifier. Also, the sequence numbers have to be consecutive starting from zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future representing the result of the registration operation itself.</para></simplesect>
<simplesect kind="note"><para>The operation will fail if the given sequence number is not unique. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="219" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1ae5f4da24c521a288098fa6e9f8b7b84e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Client</type>
          </param>
          <param>
            <type>typename Stub</type>
          </param>
        </templateparamlist>
        <type>hpx::future&lt; bool &gt;</type>
        <definition>hpx::future&lt;bool&gt; hpx::register_with_basename</definition>
        <argsstring>(std::string base_name, components::client_base&lt; Client, Stub &gt; &amp;client, std::size_t sequence_nr=~0U)</argsstring>
        <name>register_with_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>components::client_base&lt; Client, Stub &gt; &amp;</type>
          <declname>client</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>sequence_nr</declname>
          <defval>~0U</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register the id wrapped in the given client using the given base name.</para><para>The function registers the object the given client refers to using the provided base name.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Client</parametername>
</parameternamelist>
<parameterdescription>
<para>The client type to register</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>client</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The client which should be registered using the given base name. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in, optional] The sequential number to use for the registration of the id. This number has to be unique system wide for each registration using the same base name. The default is the current locality identifier. Also, the sequence numbers have to be consecutive starting from zero.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future representing the result of the registration operation itself.</para></simplesect>
<simplesect kind="note"><para>The operation will fail if the given sequence number is not unique. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="247" column="1"/>
      </memberdef>
      <memberdef kind="function" id="basename__registration__fwd_8hpp_1a8b74adbaed07646c3eaeb8bc8cbaa55d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>hpx::future&lt; hpx::id_type &gt;</type>
        <definition>Client hpx::unregister_with_basename</definition>
        <argsstring>(std::string base_name, std::size_t sequence_nr=~0U)</argsstring>
        <name>unregister_with_basename</name>
        <param>
          <type>std::string</type>
          <declname>base_name</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>sequence_nr</declname>
          <defval>~0U</defval>
        </param>
        <briefdescription>
<para>Unregister the given id using the given base name. </para>        </briefdescription>
        <detaileddescription>
<para>The function unregisters the given ids using the provided base name.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in, optional] The sequential number to use for the un-registration. This number has to be the same as has been used with <emphasis>register_with_basename</emphasis> before.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future representing the result of the un-registration operation itself.</para></simplesect>
Unregister the given base name.</para><para>The function unregisters the given ids using the provided base name.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Client</parametername>
</parameternamelist>
<parameterdescription>
<para>The client type to return</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>base_name</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The base name for which to retrieve the registered ids. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sequence_nr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in, optional] The sequential number to use for the un-registration. This number has to be the same as has been used with <emphasis>register_with_basename</emphasis> before.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A future representing the result of the un-registration operation itself. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/basename_registration_fwd.hpp" line="265" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>naming::id_type</type>
        <definition>naming::id_type hpx::find_here</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>find_here</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the global id representing this locality. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" kindref="member">find_here()</ref></emphasis> can be used to retrieve the global id usable to refer to the current locality.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<simplesect kind="return"><para>The global id representing the locality this function has been called on.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return <emphasis>hpx::naming::invalid_id</emphasis> otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__localities_8hpp_1ad7e2f65f28022cc809a10034ee8379d2" kindref="member">hpx::find_all_localities()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">hpx::find_locality()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_here.hpp" line="45" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__localities_8hpp_1a91f701414a6c667c3b58a2e50b93ad0a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>naming::id_type</type>
        <definition>naming::id_type hpx::find_root_locality</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>find_root_locality</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the global id representing the root locality. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__localities_8hpp_1a91f701414a6c667c3b58a2e50b93ad0a" kindref="member">find_root_locality()</ref></emphasis> can be used to retrieve the global id usable to refer to the root locality. The root locality is the locality where the main AGAS service is hosted.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<simplesect kind="return"><para>The global id representing the root locality for this application.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return <emphasis>hpx::naming::invalid_id</emphasis> otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__localities_8hpp_1a0f1424a2b85140c6d6bb4077601760ae" kindref="member">hpx::find_all_localities()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">hpx::find_locality()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_localities.hpp" line="49" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__localities_8hpp_1ad7e2f65f28022cc809a10034ee8379d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; naming::id_type &gt;</type>
        <definition>std::vector&lt;naming::id_type&gt; hpx::find_all_localities</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>find_all_localities</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the list of global ids representing all localities available to this application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__localities_8hpp_1a0f1424a2b85140c6d6bb4077601760ae" kindref="member">find_all_localities()</ref></emphasis> can be used to retrieve the global ids of all localities currently available to this application.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<simplesect kind="return"><para>The global ids representing the localities currently available to this application.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" kindref="member">hpx::find_here()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">hpx::find_locality()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_localities.hpp" line="78" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__localities_8hpp_1a0f1424a2b85140c6d6bb4077601760ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; naming::id_type &gt;</type>
        <definition>std::vector&lt;naming::id_type&gt; hpx::find_all_localities</definition>
        <argsstring>(components::component_type type, error_code &amp;ec=throws)</argsstring>
        <name>find_all_localities</name>
        <param>
          <type>components::component_type</type>
          <declname>type</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the list of global ids representing all localities available to this application which support the given component type. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__localities_8hpp_1a0f1424a2b85140c6d6bb4077601760ae" kindref="member">find_all_localities()</ref></emphasis> can be used to retrieve the global ids of all localities currently available to this application which support the creation of instances of the given component type.</para><para><simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The type of the components for which the function should return the available localities. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The global ids representing the localities currently available to this application which support the creation of instances of the given component type. If no localities supporting the given component type are currently available, this function will return an empty vector.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" kindref="member">hpx::find_here()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">hpx::find_locality()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_localities.hpp" line="115" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__localities_8hpp_1a9ff320f4efae1cd119f99fb27ddb8393" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; naming::id_type &gt;</type>
        <definition>std::vector&lt;naming::id_type&gt; hpx::find_remote_localities</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>find_remote_localities</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the list of locality ids of remote localities supporting the given component type. By default this function will return the list of all remote localities (all but the current locality). </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__localities_8hpp_1a6b6542b41f455b106a8952474a7ff184" kindref="member">find_remote_localities()</ref></emphasis> can be used to retrieve the global ids of all remote localities currently available to this application (i.e. all localities except the current one).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<simplesect kind="return"><para>The global ids representing the remote localities currently available to this application.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" kindref="member">hpx::find_here()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">hpx::find_locality()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_localities.hpp" line="146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__localities_8hpp_1a6b6542b41f455b106a8952474a7ff184" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; naming::id_type &gt;</type>
        <definition>std::vector&lt;naming::id_type&gt; hpx::find_remote_localities</definition>
        <argsstring>(components::component_type type, error_code &amp;ec=throws)</argsstring>
        <name>find_remote_localities</name>
        <param>
          <type>components::component_type</type>
          <declname>type</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the list of locality ids of remote localities supporting the given component type. By default this function will return the list of all remote localities (all but the current locality). </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__localities_8hpp_1a6b6542b41f455b106a8952474a7ff184" kindref="member">find_remote_localities()</ref></emphasis> can be used to retrieve the global ids of all remote localities currently available to this application (i.e. all localities except the current one) which support the creation of instances of the given component type.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The type of the components for which the function should return the available remote localities. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<simplesect kind="return"><para>The global ids representing the remote localities currently available to this application.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" kindref="member">hpx::find_here()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">hpx::find_locality()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_localities.hpp" line="180" column="1"/>
      </memberdef>
      <memberdef kind="function" id="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>naming::id_type</type>
        <definition>naming::id_type hpx::find_locality</definition>
        <argsstring>(components::component_type type, error_code &amp;ec=throws)</argsstring>
        <name>find_locality</name>
        <param>
          <type>components::component_type</type>
          <declname>type</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the global id representing an arbitrary locality which supports the given component type. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis><ref refid="find__localities_8hpp_1adde1eeefca5bbb4863e54ca81dfb1b6f" kindref="member">find_locality()</ref></emphasis> can be used to retrieve the global id of an arbitrary locality currently available to this application which supports the creation of instances of the given component type.</para><para><simplesect kind="note"><para>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>type</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The type of the components for which the function should return any available locality. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The global id representing an arbitrary locality currently available to this application which supports the creation of instances of the given component type. If no locality supporting the given component type is currently available, this function will return <emphasis>hpx::naming::invalid_id</emphasis>.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return <emphasis>hpx::naming::invalid_id</emphasis> otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="find__here_8hpp_1af07c1b6e26bcdfb1138643a1a2133cf4" kindref="member">hpx::find_here()</ref></emphasis>, <emphasis><ref refid="find__localities_8hpp_1a0f1424a2b85140c6d6bb4077601760ae" kindref="member">hpx::find_all_localities()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/find_localities.hpp" line="218" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__colocation__id_8hpp_1ad71888005ccae819b23eb88e8c4683be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>naming::id_type</type>
        <definition>naming::id_type hpx::get_colocation_id</definition>
        <argsstring>(launch::sync_policy, naming::id_type const &amp;id, error_code &amp;ec=throws)</argsstring>
        <name>get_colocation_id</name>
        <param>
          <type>launch::sync_policy</type>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the id of the locality where the object referenced by the given id is currently located on. </para>        </briefdescription>
        <detaileddescription>
<para>The function <ref refid="get__colocation__id_8hpp_1a10d1ac7350bf764e61602797b10d2f2c" kindref="member">hpx::get_colocation_id()</ref> returns the id of the locality where the given object is currently located.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The id of the object to locate. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="see"><para><emphasis><ref refid="get__colocation__id_8hpp_1a10d1ac7350bf764e61602797b10d2f2c" kindref="member">hpx::get_colocation_id()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_colocation_id.hpp" line="37" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__colocation__id_8hpp_1a10d1ac7350bf764e61602797b10d2f2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>lcos::future&lt; naming::id_type &gt;</type>
        <definition>lcos::future&lt;naming::id_type&gt; hpx::get_colocation_id</definition>
        <argsstring>(naming::id_type const &amp;id)</argsstring>
        <name>get_colocation_id</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>Asynchronously return the id of the locality where the object referenced by the given id is currently located on. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The id of the object to locate.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><emphasis>hpx::get_colocation_id(launch::sync_policy)</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_colocation_id.hpp" line="46" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__ptr_8hpp_1aeb814737de830a2e8e340ca052d5ebfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
        </templateparamlist>
        <type>hpx::future&lt; std::shared_ptr&lt; Component &gt; &gt;</type>
        <definition>hpx::future&lt;std::shared_ptr&lt;Component&gt; &gt; hpx::get_ptr</definition>
        <argsstring>(naming::id_type const &amp;id)</argsstring>
        <name>get_ptr</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>Returns a future referring to the pointer to the underlying memory of a component. </para>        </briefdescription>
        <detaileddescription>
<para>The function hpx::get_ptr can be used to extract a future referring to the pointer to the underlying memory of a given component.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The global id of the component for which the pointer to the underlying memory should be retrieved.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para>only template parameter has to be the type of the server side component.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function returns a future representing the pointer to the underlying memory for the component instance with the given <emphasis>id</emphasis>.</para></simplesect>
<simplesect kind="note"><para>This function will successfully return the requested result only if the given component is currently located on the calling locality. Otherwise the function will raise an error.</para></simplesect>
<simplesect kind="note"><para>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_ptr.hpp" line="158" column="1" bodyfile="hpx/runtime/get_ptr.hpp" bodystart="158" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="get__ptr_8hpp_1a488c36e8791a0f000ffce5ce86994602" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Stub</type>
          </param>
        </templateparamlist>
        <type>hpx::future&lt; std::shared_ptr&lt; typename components::client_base&lt; Derived, Stub &gt;::server_component_type &gt; &gt;</type>
        <definition>hpx::future&lt;std::shared_ptr&lt; typename components::client_base&lt;Derived, Stub&gt;::server_component_type &gt; &gt; hpx::get_ptr</definition>
        <argsstring>(components::client_base&lt; Derived, Stub &gt; const &amp;c)</argsstring>
        <name>get_ptr</name>
        <param>
          <type>components::client_base&lt; Derived, Stub &gt; const &amp;</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>Returns a future referring to the pointer to the underlying memory of a component. </para>        </briefdescription>
        <detaileddescription>
<para>The function hpx::get_ptr can be used to extract a future referring to the pointer to the underlying memory of a given component.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A client side representation of the component for which the pointer to the underlying memory should be retrieved.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function returns a future representing the pointer to the underlying memory for the component instance with the given <emphasis>id</emphasis>.</para></simplesect>
<simplesect kind="note"><para>This function will successfully return the requested result only if the given component is currently located on the calling locality. Otherwise the function will raise an error.</para></simplesect>
<simplesect kind="note"><para>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_ptr.hpp" line="195" column="1" bodyfile="hpx/runtime/get_ptr.hpp" bodystart="195" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="get__ptr_8hpp_1a9c602f1678bb64941918a86a6d509fb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; Component &gt;</type>
        <definition>std::shared_ptr&lt;Component&gt; hpx::get_ptr</definition>
        <argsstring>(launch::sync_policy p, naming::id_type const &amp;id, error_code &amp;ec=throws)</argsstring>
        <name>get_ptr</name>
        <param>
          <type>launch::sync_policy</type>
          <declname>p</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Returns the pointer to the underlying memory of a component. </para>        </briefdescription>
        <detaileddescription>
<para>The function hpx::get_ptr_sync can be used to extract the pointer to the underlying memory of a given component.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The parameter <emphasis>p</emphasis> represents a placeholder type to turn make the call synchronous. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The global id of the component for which the pointer to the underlying memory should be retrieved. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>The</parametername>
</parameternamelist>
<parameterdescription>
<para>only template parameter has to be the type of the server side component.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function returns the pointer to the underlying memory for the component instance with the given <emphasis>id</emphasis>.</para></simplesect>
<simplesect kind="note"><para>This function will successfully return the requested result only if the given component is currently located on the requesting locality. Otherwise the function will raise and error.</para></simplesect>
<simplesect kind="note"><para>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_ptr.hpp" line="240" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__ptr_8hpp_1afac2da8aef3362960bf207c5ad5ac2cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Derived</type>
          </param>
          <param>
            <type>typename Stub</type>
          </param>
        </templateparamlist>
        <type>std::shared_ptr&lt; typename components::client_base&lt; Derived, Stub &gt;::server_component_type &gt;</type>
        <definition>std::shared_ptr&lt; typename components::client_base&lt;Derived, Stub&gt;::server_component_type &gt; hpx::get_ptr</definition>
        <argsstring>(launch::sync_policy p, components::client_base&lt; Derived, Stub &gt; const &amp;c, error_code &amp;ec=throws)</argsstring>
        <name>get_ptr</name>
        <param>
          <type>launch::sync_policy</type>
          <declname>p</declname>
        </param>
        <param>
          <type>components::client_base&lt; Derived, Stub &gt; const &amp;</type>
          <declname>c</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Returns the pointer to the underlying memory of a component. </para>        </briefdescription>
        <detaileddescription>
<para>The function hpx::get_ptr_sync can be used to extract the pointer to the underlying memory of a given component.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The parameter <emphasis>p</emphasis> represents a placeholder type to turn make the call synchronous. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A client side representation of the component for which the pointer to the underlying memory should be retrieved. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function returns the pointer to the underlying memory for the component instance with the given <emphasis>id</emphasis>.</para></simplesect>
<simplesect kind="note"><para>This function will successfully return the requested result only if the given component is currently located on the requesting locality. Otherwise the function will raise and error.</para></simplesect>
<simplesect kind="note"><para>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_ptr.hpp" line="298" column="1" bodyfile="hpx/runtime/get_ptr.hpp" bodystart="298" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="get__locality__id_8hpp_1a158d7c54a657bb364c1704033010697b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t hpx::get_locality_id</definition>
        <argsstring>(error_code &amp;ec=throws)</argsstring>
        <name>get_locality_id</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the number of the locality this function is being called from. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the id of the current locality.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The returned value is zero based and its maximum value is smaller than the overall number of localities the current application is running on (as returned by <emphasis><ref refid="get__num__localities_8hpp_1a4dd860f6c435319c019eed326455f646" kindref="member">get_num_localities()</ref></emphasis>).</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will fail otherwise (it will return -1). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_locality_id.hpp" line="42" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__locality__name_8hpp_1af59b323d00d708f6f9faed64817f15f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hpx::get_locality_name</definition>
        <argsstring>()</argsstring>
        <name>get_locality_name</name>
        <briefdescription>
<para>Return the name of the locality this function is called on. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the name for the locality on which this function is called.</para><para><simplesect kind="return"><para>This function returns the name for the locality on which the function is called. The name is retrieved from the underlying networking layer and may be different for different parcelports.</para></simplesect>
<simplesect kind="see"><para><emphasis>future&lt;std::string&gt;</emphasis> get_locality_name(naming::id_type const&amp; id) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_locality_name.hpp" line="31" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__locality__name_8hpp_1af9a88c1545670a4cbde4e2f3320666d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>future&lt; std::string &gt;</type>
        <definition>future&lt; std::string &gt; hpx::get_locality_name</definition>
        <argsstring>(naming::id_type const &amp;id)</argsstring>
        <name>get_locality_name</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>Return the name of the referenced locality. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns a future referring to the name for the locality of the given id.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The global id of the locality for which the name should be retrieved</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This function returns the name for the locality of the given id. The name is retrieved from the underlying networking layer and may be different for different parcel ports.</para></simplesect>
<simplesect kind="see"><para><emphasis>std::string</emphasis> <ref refid="get__locality__name_8hpp_1af9a88c1545670a4cbde4e2f3320666d5" kindref="member">get_locality_name()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_locality_name.hpp" line="48" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__num__localities_8hpp_1a68d4aa44bb8e58c6b0a6aff2920fdd8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t hpx::get_initial_num_localities</definition>
        <argsstring>()</argsstring>
        <name>get_initial_num_localities</name>
        <briefdescription>
<para>Return the number of localities which were registered at startup for the running application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>get_initial_num_localities</emphasis> returns the number of localities which were connected to the console at application startup.</para><para><simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::find_all_localities</emphasis>, <emphasis>hpx::get_num_localities</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_num_localities.hpp" line="34" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__num__localities_8hpp_1a4dd860f6c435319c019eed326455f646" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>lcos::future&lt; std::uint32_t &gt;</type>
        <definition>lcos::future&lt;std::uint32_t&gt; hpx::get_num_localities</definition>
        <argsstring>()</argsstring>
        <name>get_num_localities</name>
        <briefdescription>
<para>Asynchronously return the number of localities which are currently registered for the running application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>get_num_localities</emphasis> asynchronously returns the number of localities currently connected to the console. The returned future represents the actual result.</para><para><simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::find_all_localities</emphasis>, <emphasis>hpx::get_num_localities</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_num_localities.hpp" line="48" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__num__localities_8hpp_1acc87bce31e8a2758be4aef89def33204" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t hpx::get_num_localities</definition>
        <argsstring>(launch::sync_policy, error_code &amp;ec=throws)</argsstring>
        <name>get_num_localities</name>
        <param>
          <type>launch::sync_policy</type>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Return the number of localities which are currently registered for the running application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>get_num_localities</emphasis> returns the number of localities currently connected to the console.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::find_all_localities</emphasis>, <emphasis>hpx::get_num_localities</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_num_localities.hpp" line="70" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__num__localities_8hpp_1ad87429472cce631ff4aa3b9538850cc8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>lcos::future&lt; std::uint32_t &gt;</type>
        <definition>lcos::future&lt;std::uint32_t&gt; hpx::get_num_localities</definition>
        <argsstring>(components::component_type t)</argsstring>
        <name>get_num_localities</name>
        <param>
          <type>components::component_type</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Asynchronously return the number of localities which are currently registered for the running application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>get_num_localities</emphasis> asynchronously returns the number of localities currently connected to the console which support the creation of the given component type. The returned future represents the actual result.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The component type for which the number of connected localities should be retrieved.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::find_all_localities</emphasis>, <emphasis>hpx::get_num_localities</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_num_localities.hpp" line="88" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__num__localities_8hpp_1ae3d554fde53654e1812e72cec6198bd5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t hpx::get_num_localities</definition>
        <argsstring>(launch::sync_policy, components::component_type t, error_code &amp;ec=throws)</argsstring>
        <name>get_num_localities</name>
        <param>
          <type>launch::sync_policy</type>
        </param>
        <param>
          <type>components::component_type</type>
          <declname>t</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
<para>Synchronously return the number of localities which are currently registered for the running application. </para>        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>get_num_localities</emphasis> returns the number of localities currently connected to the console which support the creation of the given component type. The returned future represents the actual result.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The component type for which the number of connected localities should be retrieved. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::find_all_localities</emphasis>, <emphasis>hpx::get_num_localities</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_num_localities.hpp" line="108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__os__thread__count_8hpp_1a7899ab2136e9b3ba674caf70aa659a59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t hpx::get_os_thread_count</definition>
        <argsstring>()</argsstring>
        <name>get_os_thread_count</name>
        <briefdescription>
<para>Return the number of OS-threads running in the runtime instance the current HPX-thread is associated with. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_os_thread_count.hpp" line="21" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__os__thread__count_8hpp_1adcb3c8ac96fa1583317926a64a1abd3a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t hpx::get_os_thread_count</definition>
        <argsstring>(threads::executor const &amp;exec)</argsstring>
        <name>get_os_thread_count</name>
        <param>
          <type>threads::executor const &amp;</type>
          <declname>exec</declname>
        </param>
        <briefdescription>
<para>Return the number of worker OS- threads used by the given executor to execute HPX threads. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the number of cores used to execute HPX threads for the given executor. If the function is called while no HPX runtime system is active, it will return zero. If the executor is not valid, this function will fall back to retrieving the number of OS threads used by HPX.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>exec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The executor to be used. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_os_thread_count.hpp" line="33" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__thread__name_8hpp_1aaa2a7b43b2655775e3811d5a3f9c0f5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hpx::get_thread_name</definition>
        <argsstring>()</argsstring>
        <name>get_thread_name</name>
        <briefdescription>
<para>Return the name of the calling thread. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the name of the calling thread. This name uniquely identifies the thread in the context of HPX. If the function is called while no HPX runtime system is active, the result will be &quot;&lt;unknown&gt;&quot;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_thread_name.hpp" line="25" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__worker__thread__num_8hpp_1ad438935ca2f8603f9cab036b68b34f36" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t hpx::get_worker_thread_num</definition>
        <argsstring>()</argsstring>
        <name>get_worker_thread_num</name>
        <briefdescription>
<para>Return the number of the current OS-thread running in the runtime instance the current HPX-thread is executed with. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the zero based index of the OS-thread which executes the current HPX-thread.</para><para><simplesect kind="note"><para>The returned value is zero based and its maximum value is smaller than the overall number of OS-threads executed (as returned by <emphasis><ref refid="get__os__thread__count_8hpp_1a7899ab2136e9b3ba674caf70aa659a59" kindref="member">get_os_thread_count()</ref></emphasis>.</para></simplesect>
<simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will fail otherwise (it will return -1). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_worker_thread_num.hpp" line="31" column="1"/>
      </memberdef>
      <memberdef kind="function" id="get__worker__thread__num_8hpp_1adc17eda7c3c7c6b2a0f7cb1affed8520" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::size_t</type>
        <definition>std::size_t hpx::get_worker_thread_num</definition>
        <argsstring>(error_code &amp;ec)</argsstring>
        <name>get_worker_thread_num</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
        </param>
        <briefdescription>
<para>Return the number of the current OS-thread running in the runtime instance the current HPX-thread is executed with. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns the zero based index of the OS-thread which executes the current HPX-thread.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The returned value is zero based and its maximum value is smaller than the overall number of OS-threads executed (as returned by <emphasis><ref refid="get__os__thread__count_8hpp_1a7899ab2136e9b3ba674caf70aa659a59" kindref="member">get_os_thread_count()</ref></emphasis>. It will return -1 if the current thread is not a known thread or if the runtime is not in running state.</para></simplesect>
<simplesect kind="note"><para>This function needs to be executed on a HPX-thread. It will fail otherwise (it will return -1). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/get_worker_thread_num.hpp" line="50" column="1"/>
      </memberdef>
      <memberdef kind="function" id="report__error_8hpp_1ad3a47f9cb15f1800be181e4f249a0ede" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::report_error</definition>
        <argsstring>(std::size_t num_thread, std::exception_ptr const &amp;e)</argsstring>
        <name>report_error</name>
        <param>
          <type>std::size_t</type>
          <declname>num_thread</declname>
        </param>
        <param>
          <type>std::exception_ptr const &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>The function report_error reports the given exception to the console. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/report_error.hpp" line="19" column="1"/>
      </memberdef>
      <memberdef kind="function" id="report__error_8hpp_1a7eee13362368297121876ddbed28afb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::report_error</definition>
        <argsstring>(std::exception_ptr const &amp;e)</argsstring>
        <name>report_error</name>
        <param>
          <type>std::exception_ptr const &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>The function report_error reports the given exception to the console. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/report_error.hpp" line="23" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__mode_8hpp_1a5142a5307ed300520b3bb1d6e57bd82b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>char const  *</type>
        <definition>char const* hpx::get_runtime_mode_name</definition>
        <argsstring>(runtime_mode state)</argsstring>
        <name>get_runtime_mode_name</name>
        <param>
          <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">runtime_mode</ref></type>
          <declname>state</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the readable string representing the name of the given runtime_mode constant. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/runtime_mode.hpp" line="34" column="1"/>
      </memberdef>
      <memberdef kind="function" id="runtime__mode_8hpp_1a11d80cdb93e72f01fcace23152950bf8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="runtime__mode_8hpp_1a380cead581c9f4b6ec569a355f9440bf" kindref="member">runtime_mode</ref></type>
        <definition>runtime_mode hpx::get_runtime_mode_from_name</definition>
        <argsstring>(std::string const &amp;mode)</argsstring>
        <name>get_runtime_mode_from_name</name>
        <param>
          <type>std::string const &amp;</type>
          <declname>mode</declname>
        </param>
        <briefdescription>
<para>Returns the internal representation (runtime_mode constant) from the readable string representing the name. </para>        </briefdescription>
        <detaileddescription>
<para>This represents the internal representation from the readable string representing the name.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>this represents the runtime mode </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/runtime_mode.hpp" line="44" column="1"/>
      </memberdef>
      <memberdef kind="function" id="set__parcel__write__handler_8hpp_1aeb594d703895a387b89e4fba621b13f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>parcel_write_handler_type</type>
        <definition>parcel_write_handler_type hpx::set_parcel_write_handler</definition>
        <argsstring>(parcel_write_handler_type const &amp;f)</argsstring>
        <name>set_parcel_write_handler</name>
        <param>
          <type>parcel_write_handler_type const &amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the default parcel write handler which is invoked once a parcel has been sent if no explicit write handler was specified.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The new parcel write handler to use from this point on</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function returns the parcel write handler which was installed before this function was called.</para></simplesect>
<simplesect kind="note"><para>If no parcel handler function is registered by the user the system will call a default parcel handler function which is not performing any actions. However, this default function will terminate the application in case of any errors detected during preparing or sending the parcel. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/set_parcel_write_handler.hpp" line="43" column="1"/>
      </memberdef>
      <memberdef kind="function" id="shutdown__function_8hpp_1af9d4996bd26c9518cad472ae5da0e52b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::register_pre_shutdown_function</definition>
        <argsstring>(shutdown_function_type f)</argsstring>
        <name>register_pre_shutdown_function</name>
        <param>
          <type>shutdown_function_type</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Add a function to be executed by a HPX thread during <emphasis><ref refid="hpx__finalize_8hpp_1ab7eb159cb77997b366b5d79e65f04cd0" kindref="member">hpx::finalize()</ref></emphasis> but guaranteed before any shutdown function is executed (system-wide) </para>        </briefdescription>
        <detaileddescription>
<para>Any of the functions registered with <emphasis>register_pre_shutdown_function</emphasis> are guaranteed to be executed by an HPX thread during the execution of <emphasis><ref refid="hpx__finalize_8hpp_1ab7eb159cb77997b366b5d79e65f04cd0" kindref="member">hpx::finalize()</ref></emphasis> before any of the registered shutdown functions are executed (see: <emphasis>hpx::register_shutdown_function()</emphasis>).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be registered to run by an HPX thread as a pre-shutdown function.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>If this function is called while the pre-shutdown functions are being executed, or after that point, it will raise a invalid_status exception.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::register_shutdown_function()</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/shutdown_function.hpp" line="38" column="1"/>
      </memberdef>
      <memberdef kind="function" id="shutdown__function_8hpp_1af2378fac549f2d83f691f5990fcd3453" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::register_shutdown_function</definition>
        <argsstring>(shutdown_function_type f)</argsstring>
        <name>register_shutdown_function</name>
        <param>
          <type>shutdown_function_type</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Add a function to be executed by a HPX thread during <emphasis><ref refid="hpx__finalize_8hpp_1ab7eb159cb77997b366b5d79e65f04cd0" kindref="member">hpx::finalize()</ref></emphasis> but guaranteed after any pre-shutdown function is executed (system-wide) </para>        </briefdescription>
        <detaileddescription>
<para>Any of the functions registered with <emphasis>register_shutdown_function</emphasis> are guaranteed to be executed by an HPX thread during the execution of <emphasis><ref refid="hpx__finalize_8hpp_1ab7eb159cb77997b366b5d79e65f04cd0" kindref="member">hpx::finalize()</ref></emphasis> after any of the registered pre-shutdown functions are executed (see: <emphasis>hpx::register_pre_shutdown_function()</emphasis>).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be registered to run by an HPX thread as a shutdown function.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>If this function is called while the shutdown functions are being executed, or after that point, it will raise a invalid_status exception.</para></simplesect>
<simplesect kind="see"><para><emphasis>hpx::register_pre_shutdown_function()</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/shutdown_function.hpp" line="57" column="1"/>
      </memberdef>
      <memberdef kind="function" id="startup__function_8hpp_1af4a89a9a8c4f3d8d4d256fcf5a9093fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::register_pre_startup_function</definition>
        <argsstring>(startup_function_type f)</argsstring>
        <name>register_pre_startup_function</name>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Add a function to be executed by a HPX thread before hpx_main but guaranteed before any startup function is executed (system-wide). </para>        </briefdescription>
        <detaileddescription>
<para>Any of the functions registered with <emphasis>register_pre_startup_function</emphasis> are guaranteed to be executed by an HPX thread before any of the registered startup functions are executed (see <emphasis><ref refid="startup__function_8hpp_1a606821ec55263e6dc0905e8ac9c47e7e" kindref="member">hpx::register_startup_function()</ref></emphasis>).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be registered to run by an HPX thread as a pre-startup function.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>If this function is called while the pre-startup functions are being executed or after that point, it will raise a invalid_status exception.</para></simplesect>
This function is one of the few API functions which can be called before the runtime system has been fully initialized. It will automatically stage the provided startup function to the runtime system during its initialization (if necessary).</para><para><simplesect kind="see"><para><emphasis><ref refid="startup__function_8hpp_1a606821ec55263e6dc0905e8ac9c47e7e" kindref="member">hpx::register_startup_function()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/startup_function.hpp" line="44" column="1"/>
      </memberdef>
      <memberdef kind="function" id="startup__function_8hpp_1a606821ec55263e6dc0905e8ac9c47e7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::register_startup_function</definition>
        <argsstring>(startup_function_type f)</argsstring>
        <name>register_startup_function</name>
        <param>
          <type><ref refid="startup__function_8hpp_1a182edb67dcfa1c3aa5fa9c30faaa43d7" kindref="member">startup_function_type</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Add a function to be executed by a HPX thread before hpx_main but guaranteed after any pre-startup function is executed (system-wide). </para>        </briefdescription>
        <detaileddescription>
<para>Any of the functions registered with <emphasis>register_startup_function</emphasis> are guaranteed to be executed by an HPX thread after any of the registered pre-startup functions are executed (see: <emphasis><ref refid="startup__function_8hpp_1af4a89a9a8c4f3d8d4d256fcf5a9093fc" kindref="member">hpx::register_pre_startup_function()</ref></emphasis>), but before <emphasis>hpx_main</emphasis> is being called.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The function to be registered to run by an HPX thread as a startup function.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>If this function is called while the startup functions are being executed or after that point, it will raise a invalid_status exception.</para></simplesect>
This function is one of the few API functions which can be called before the runtime system has been fully initialized. It will automatically stage the provided startup function to the runtime system during its initialization (if necessary).</para><para><simplesect kind="see"><para><emphasis><ref refid="startup__function_8hpp_1af4a89a9a8c4f3d8d4d256fcf5a9093fc" kindref="member">hpx::register_pre_startup_function()</ref></emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/startup_function.hpp" line="69" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a490eaa9c98d00ed130f79ceb3752aa70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::trigger_lco_event</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, bool move_credits=true)</argsstring>
        <name>trigger_lco_event</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Trigger the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="37" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1aee5263bb66115a5b7a4fc3e0a9ebfe05" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::trigger_lco_event</definition>
        <argsstring>(naming::id_type const &amp;id, bool move_credits=true)</argsstring>
        <name>trigger_lco_event</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Trigger the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="48" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="48" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1ac077308029ea3e2b7d240123fdbf3c2b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::trigger_lco_event</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>trigger_lco_event</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Trigger the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="64" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a40c094e74b6dafbda7384b5abaa87608" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::trigger_lco_event</definition>
        <argsstring>(naming::id_type const &amp;id, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>trigger_lco_event</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Trigger the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="76" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="76" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1ac39c86d0a66ad9dba32b6206499dd80f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Result</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::set_lco_value</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, Result &amp;&amp;t, bool move_credits=true)</argsstring>
        <name>set_lco_value</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>Result &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the result value for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the given value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="93" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a05c65a0220aff046a181cb6e14dd316b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Result</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; !std::is_same&lt; typename util::decay&lt; Result &gt;::type, naming::address &gt;::value &gt;::type</type>
        <definition>std::enable_if&lt; !std::is_same&lt;typename util::decay&lt;Result&gt;::type, naming::address&gt;::value &gt;::type hpx::set_lco_value</definition>
        <argsstring>(naming::id_type const &amp;id, Result &amp;&amp;t, bool move_credits=true)</argsstring>
        <name>set_lco_value</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>Result &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the result value for the (managed) LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the given value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="108" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="108" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1acde4bb5dada3349bd52512791239ce70" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Result</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; !std::is_same&lt; typename util::decay&lt; Result &gt;::type, naming::address &gt;::value &gt;::type</type>
        <definition>std::enable_if&lt; !std::is_same&lt;typename util::decay&lt;Result&gt;::type, naming::address&gt;::value &gt;::type hpx::set_lco_value_unmanaged</definition>
        <argsstring>(naming::id_type const &amp;id, Result &amp;&amp;t, bool move_credits=true)</argsstring>
        <name>set_lco_value_unmanaged</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>Result &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the result value for the (unmanaged) LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the given value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="126" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="126" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1aaef2f83c6529712c6bd720ceb081ba06" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Result</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::set_lco_value</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, Result &amp;&amp;t, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_value</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>Result &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the result value for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the given value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="146" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a136a26af26eb9478e0f9d5e98f54e4b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Result</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; !std::is_same&lt; typename util::decay&lt; Result &gt;::type, naming::address &gt;::value &gt;::type</type>
        <definition>std::enable_if&lt; !std::is_same&lt;typename util::decay&lt;Result&gt;::type, naming::address&gt;::value &gt;::type hpx::set_lco_value</definition>
        <argsstring>(naming::id_type const &amp;id, Result &amp;&amp;t, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_value</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>Result &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the result value for the (managed) LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the given value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="163" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="163" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1af1706601c83026e3adb568d436b33fbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Result</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; !std::is_same&lt; typename util::decay&lt; Result &gt;::type, naming::address &gt;::value &gt;::type</type>
        <definition>std::enable_if&lt; !std::is_same&lt;typename util::decay&lt;Result&gt;::type, naming::address&gt;::value &gt;::type hpx::set_lco_value_unmanaged</definition>
        <argsstring>(naming::id_type const &amp;id, Result &amp;&amp;t, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_value_unmanaged</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>Result &amp;&amp;</type>
          <declname>t</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the result value for the (unmanaged) LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the given value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="184" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="184" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1af0c26df1ee631f99d7bb04ec2507c900" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, std::exception_ptr const &amp;e, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>std::exception_ptr const &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="204" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a5212afa7a0c98340c84329667ee9d76d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, std::exception_ptr &amp;&amp;e, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>std::exception_ptr &amp;&amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="219" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a4319f12b95c698b336d3bddcdc86fa9a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, std::exception_ptr const &amp;e, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::exception_ptr const &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="232" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="232" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a31702a9ce79826a733156e3e4d1bc086" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, std::exception_ptr &amp;&amp;e, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::exception_ptr &amp;&amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="247" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="247" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1acf6b5cb329463f47953fff7d4fcfb620" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, std::exception_ptr const &amp;e, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>std::exception_ptr const &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="265" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a09c2fb701954a101f1d9bedb94f1ed19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, naming::address &amp;&amp;addr, std::exception_ptr &amp;&amp;e, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>naming::address &amp;&amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>std::exception_ptr &amp;&amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>addr</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the addr of the LCO which should be triggered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="281" column="1"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1a49faf5cfa444c6e603b89d704bc15d7d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, std::exception_ptr const &amp;e, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::exception_ptr const &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="295" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="295" bodyend="300"/>
      </memberdef>
      <memberdef kind="function" id="trigger__lco_8hpp_1ada564cac88cc7c4d5cd03f7c55d7e7f2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::set_lco_error</definition>
        <argsstring>(naming::id_type const &amp;id, std::exception_ptr &amp;&amp;e, naming::id_type const &amp;cont, bool move_credits=true)</argsstring>
        <name>set_lco_error</name>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>id</declname>
        </param>
        <param>
          <type>std::exception_ptr &amp;&amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>naming::id_type const &amp;</type>
          <declname>cont</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>move_credits</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Set the error state for the LCO referenced by the given id. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>id</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the id of the LCO which should receive the error value. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This is the error value which should be sent to the LCO. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cont</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] This represents the LCO to trigger after completion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>move_credits</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] If this is set to <emphasis>true</emphasis> then it is ok to send all credits in <emphasis>id</emphasis> along with the generated message. The default value is <emphasis>true</emphasis>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/trigger_lco.hpp" line="312" column="1" bodyfile="hpx/runtime/trigger_lco.hpp" bodystart="312" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="new_8hpp_1aa43897833f0f0ed2afc53006fc80dad5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>&lt; unspecified &gt;</type>
        <definition>&lt;unspecified&gt; hpx::new_</definition>
        <argsstring>(id_type const &amp;locality, Ts &amp;&amp;... vs)</argsstring>
        <name>new_</name>
        <param>
          <type>id_type const &amp;</type>
          <declname>locality</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>vs</declname>
        </param>
        <briefdescription>
<para>Create one or more new instances of the given Component type on the specified locality. </para>        </briefdescription>
        <detaileddescription>
<para>This function creates one or more new instances of the given Component type on the specified locality and returns a future object for the global address which can be used to reference the new component instance.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>locality</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The global address of the locality where the new instance should be created on. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vs</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <programlisting><codeline><highlight class="normal">hpx::future&lt;hpx::id_type&gt;<sp/>f<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>hpx::new_&lt;some_component&gt;(hpx::find_here(),<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">hpx::id_type<sp/>id<sp/>=<sp/>f.get();</highlight></codeline>
</programlisting></para></simplesect>
<simplesect kind="return"><para>The function returns different types depending on its use:<linebreak/>
<itemizedlist>
<listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents a component type (<computeroutput>traits::is_component&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which can be used to retrieve the global address of the newly created component.</para></listitem><listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents a client side object (<computeroutput>traits::is_client&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return a new instance of that type which can be used to refer to the newly created component instance. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/components/new.hpp" line="71" column="1"/>
      </memberdef>
      <memberdef kind="function" id="new_8hpp_1afe0790913a2940c611d6e4a0e738821f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>&lt; unspecified &gt;</type>
        <definition>&lt;unspecified&gt; hpx::local_new</definition>
        <argsstring>(Ts &amp;&amp;... vs)</argsstring>
        <name>local_new</name>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>vs</declname>
        </param>
        <briefdescription>
<para>Create one new instance of the given Component type on the current locality. </para>        </briefdescription>
        <detaileddescription>
<para>This function creates one new instance of the given Component type on the current locality and returns a future object for the global address which can be used to reference the new component instance.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vs</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <programlisting><codeline><highlight class="normal">hpx::future&lt;hpx::id_type&gt;<sp/>f<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>hpx::local_new&lt;some_component&gt;(...);</highlight></codeline>
<codeline><highlight class="normal">hpx::id_type<sp/>id<sp/>=<sp/>f.get();</highlight></codeline>
</programlisting></para></simplesect>
<simplesect kind="return"><para>The function returns different types depending on its use:<linebreak/>
<itemizedlist>
<listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents a component type (<computeroutput>traits::is_component&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which can be used to retrieve the global address of the newly created component. If the first argument is <computeroutput><ref refid="structhpx_1_1launch_1a63234dfc5eb5ddbd51fe2d0de1ecfa3c" kindref="member">hpx::launch::sync</ref></computeroutput> the function will directly return an <computeroutput>hpx::id_type</computeroutput>.</para></listitem><listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents a client side object (<computeroutput>traits::is_client&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return a new instance of that type which can be used to refer to the newly created component instance.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>The difference of this funtion to <emphasis>hpx::new_</emphasis> is that it can be used in cases where the supplied arguments are non-copyable and non-movable. All operations are guaranteed to be local only. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/components/new.hpp" line="116" column="1"/>
      </memberdef>
      <memberdef kind="function" id="new_8hpp_1aea2980125a99fd4c163b868f29516221" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>&lt; unspecified &gt;</type>
        <definition>&lt;unspecified&gt; hpx::new_</definition>
        <argsstring>(id_type const &amp;locality, std::size_t count, Ts &amp;&amp;... vs)</argsstring>
        <name>new_</name>
        <param>
          <type>id_type const &amp;</type>
          <declname>locality</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>vs</declname>
        </param>
        <briefdescription>
<para>Create multiple new instances of the given Component type on the specified locality. </para>        </briefdescription>
        <detaileddescription>
<para>This function creates multiple new instances of the given Component type on the specified locality and returns a future object for the global address which can be used to reference the new component instance.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>locality</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The global address of the locality where the new instance should be created on. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of component instances to create </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vs</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <programlisting><codeline><highlight class="normal">hpx::future&lt;std::vector&lt;hpx::id_type&gt;<sp/>&gt;<sp/>f<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>hpx::new_&lt;some_component[]&gt;(hpx::find_here(),<sp/>10,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">hpx::id_type<sp/>id<sp/>=<sp/>f.get();</highlight></codeline>
</programlisting></para></simplesect>
<simplesect kind="return"><para>The function returns different types depending on its use:<linebreak/>
<itemizedlist>
<listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents an array of a component type (i.e. <emphasis>Component</emphasis>[], where <computeroutput>traits::is_component&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a global address of one of the newly created components.</para></listitem><listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents an array of a client side object type (i.e. <emphasis>Component</emphasis>[], where <computeroutput>traits::is_client&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a client side instance of the given type, each representing one of the newly created components. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/components/new.hpp" line="162" column="1"/>
      </memberdef>
      <memberdef kind="function" id="new_8hpp_1aa9f418d7039ba0ff4b13917c158b6630" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
          <param>
            <type>typename DistPolicy</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>&lt; unspecified &gt;</type>
        <definition>&lt;unspecified&gt; hpx::new_</definition>
        <argsstring>(DistPolicy const &amp;policy, Ts &amp;&amp;... vs)</argsstring>
        <name>new_</name>
        <param>
          <type>DistPolicy const &amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>vs</declname>
        </param>
        <briefdescription>
<para>Create one or more new instances of the given Component type based on the given distribution policy. </para>        </briefdescription>
        <detaileddescription>
<para>This function creates one or more new instances of the given Component type on the localities defined by the given distribution policy and returns a future object for global address which can be used to reference the new component instance(s).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The distribution policy used to decide where to place the newly created. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vs</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <programlisting><codeline><highlight class="normal">hpx::future&lt;hpx::id_type&gt;<sp/>f<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>hpx::new_&lt;some_component&gt;(hpx::default_layout,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">hpx::id_type<sp/>id<sp/>=<sp/>f.get();</highlight></codeline>
</programlisting></para></simplesect>
<simplesect kind="return"><para>The function returns different types depending on its use:<linebreak/>
<itemizedlist>
<listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents a component type (<computeroutput>traits::is_component&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which can be used to retrieve the global address of the newly created component.</para></listitem><listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents a client side object (<computeroutput>traits::is_client&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return a new instance of that type which can be used to refer to the newly created component instance. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/components/new.hpp" line="202" column="1"/>
      </memberdef>
      <memberdef kind="function" id="new_8hpp_1ad90881264fb7fbb31ed956e5573b0f66" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Component</type>
          </param>
          <param>
            <type>typename DistPolicy</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>&lt; unspecified &gt;</type>
        <definition>&lt;unspecified&gt; hpx::new_</definition>
        <argsstring>(DistPolicy const &amp;policy, std::size_t count, Ts &amp;&amp;... vs)</argsstring>
        <name>new_</name>
        <param>
          <type>DistPolicy const &amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>vs</declname>
        </param>
        <briefdescription>
<para>Create multiple new instances of the given Component type on the localities as defined by the given distribution policy. </para>        </briefdescription>
        <detaileddescription>
<para>This function creates multiple new instances of the given Component type on the localities defined by the given distribution policy and returns a future object for the global address which can be used to reference the new component instance.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The distribution policy used to decide where to place the newly created. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of component instances to create </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vs</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <programlisting><codeline><highlight class="normal">hpx::future&lt;std::vector&lt;hpx::id_type&gt;<sp/>&gt;<sp/>f<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>hpx::new_&lt;some_component[]&gt;(hpx::default_layout,<sp/>10,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">hpx::id_type<sp/>id<sp/>=<sp/>f.get();</highlight></codeline>
</programlisting></para></simplesect>
<simplesect kind="return"><para>The function returns different types depending on its use:<linebreak/>
<itemizedlist>
<listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents an array of a component type (i.e. <emphasis>Component</emphasis>[], where <computeroutput>traits::is_component&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a global address of one of the newly created components.<linebreak/>
</para></listitem><listitem><para>If the explicit template argument <emphasis>Component</emphasis> represents an array of a client side object type (i.e. <emphasis>Component</emphasis>[], where <computeroutput>traits::is_client&lt;Component&gt;::value</computeroutput> evaluates to true), the function will return an <emphasis>hpx::future</emphasis> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a client side instance of the given type, each representing one of the newly created components. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/runtime/components/new.hpp" line="248" column="1"/>
      </memberdef>
      <memberdef kind="function" id="split__future_8hpp_1a316e1a9ed8e48a5cd1ad58c150c0b990" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>tuple&lt; future&lt; Ts &gt;... &gt;</type>
        <definition>tuple&lt;future&lt;Ts&gt;...&gt; hpx::split_future</definition>
        <argsstring>(future&lt; tuple&lt; Ts... &gt; &gt; &amp;&amp;f)</argsstring>
        <name>split_future</name>
        <param>
          <type>future&lt; tuple&lt; Ts... &gt; &gt; &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>split_future</emphasis> is an operator allowing to split a given future of a sequence of values (any tuple, std::pair, or std::array) into an equivalent container of futures where each future represents one of the values from the original future. In some sense this function provides the inverse operation of <emphasis>when_all</emphasis>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A future holding an arbitrary sequence of values stored in a tuple-like container. This facility supports <emphasis>hpx::util::tuple&lt;&gt;</emphasis>, <emphasis>std::pair&lt;T1, T2&gt;</emphasis>, and <emphasis>std::array&lt;T, N&gt;</emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns an equivalent container (same container type as passed as the argument) of futures, where each future refers to the corresponding value in the input parameter. All of the returned futures become ready once the input future has become ready. If the input future is exceptional, all output futures will be exceptional as well.</para></simplesect>
<simplesect kind="note"><para>The following cases are special: <programlisting><codeline><highlight class="normal">tuple&lt;future&lt;void&gt;<sp/>&gt;<sp/>split_future(future&lt;tuple&lt;&gt;<sp/>&gt;<sp/>&amp;&amp;<sp/>f);</highlight></codeline>
<codeline><highlight class="normal">array&lt;future&lt;void&gt;,<sp/>1&gt;<sp/>split_future(future&lt;array&lt;T,<sp/>0&gt;<sp/>&gt;<sp/>&amp;&amp;<sp/>f);</highlight></codeline>
</programlisting> here the returned futures are directly representing the futures which were passed to the function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/split_future.hpp" line="42" column="1"/>
      </memberdef>
      <memberdef kind="function" id="split__future_8hpp_1a790ed8efd6e91700384fe44b7e363157" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; future&lt; T &gt; &gt;</type>
        <definition>std::vector&lt;future&lt;T&gt; &gt; hpx::split_future</definition>
        <argsstring>(future&lt; std::vector&lt; T &gt; &gt; &amp;&amp;f, std::size_t size)</argsstring>
        <name>split_future</name>
        <param>
          <type>future&lt; std::vector&lt; T &gt; &gt; &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>split_future</emphasis> is an operator allowing to split a given future of a sequence of values (any std::vector) into a std::vector of futures where each future represents one of the values from the original std::vector. In some sense this function provides the inverse operation of <emphasis>when_all</emphasis>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A future holding an arbitrary sequence of values stored in a std::vector. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of elements the vector will hold once the input future has become ready</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a std::vector of futures, where each future refers to the corresponding value in the input parameter. All of the returned futures become ready once the input future has become ready. If the input future is exceptional, all output futures will be exceptional as well. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/split_future.hpp" line="63" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__all_8hpp_1a2813387f73914c8820932b17345a9a3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_all</definition>
        <argsstring>(InputIter first, InputIter last)</argsstring>
        <name>wait_all</name>
        <param>
          <type>InputIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after all futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_all.hpp" line="34" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__all_8hpp_1a66b1f971ef6e3a7047209f46bb5363a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_all</definition>
        <argsstring>(std::vector&lt; future&lt; R &gt;&gt; &amp;&amp;futures)</argsstring>
        <name>wait_all</name>
        <param>
          <type>std::vector&lt; future&lt; R &gt;&gt; &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector or array holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after all futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_all.hpp" line="49" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__all_8hpp_1a3708e444b4d1b065391134bce018bac5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_all</definition>
        <argsstring>(std::array&lt; future&lt; R &gt;, N &gt; &amp;&amp;futures)</argsstring>
        <name>wait_all</name>
        <param>
          <type>std::array&lt; future&lt; R &gt;, N &gt; &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector or array holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after all futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_all.hpp" line="64" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__all_8hpp_1afb0e337050655c63eb2037276c45936c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_all</definition>
        <argsstring>(T &amp;&amp;... futures)</argsstring>
        <name>wait_all</name>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>wait_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after all futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_all.hpp" line="79" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__all_8hpp_1aca58b9f93caf250031cbf3aa4aaec489" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
        </templateparamlist>
        <type>InputIter</type>
        <definition>InputIter hpx::wait_all_n</definition>
        <argsstring>(InputIter begin, std::size_t count)</argsstring>
        <name>wait_all_n</name>
        <param>
          <type>InputIter</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_all_n</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_all_n</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of elements in the sequence starting at <emphasis>first</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The function <emphasis>wait_all_n</emphasis> will return an iterator referring to the first element in the input sequence after the last processed element.</para></simplesect>
<simplesect kind="note"><para>The function <emphasis>wait_all_n</emphasis> returns after all futures have become ready. All input futures are still valid after <emphasis>wait_all_n</emphasis> returns. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_all.hpp" line="100" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__all_8hpp_1a5ad5592e9ab00e19076037495d55d3e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
          <param>
            <type>typename Container</type>
            <defval>vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>future&lt; Container &gt;</type>
        <definition>future&lt;Container&gt; hpx::when_all</definition>
        <argsstring>(InputIter first, InputIter last)</argsstring>
        <name>when_all</name>
        <param>
          <type>InputIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a future holding the same list of futures as has been passed to <emphasis>when_all</emphasis>.<itemizedlist>
<listitem><para>future&lt;Container&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>when_all</emphasis> where first == last, returns a future with an empty container that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_all</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_all.hpp" line="45" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__all_8hpp_1a2162cc879aa5c37b993e641f5e62bcfc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type>future&lt; Range &gt;</type>
        <definition>future&lt;Range&gt; hpx::when_all</definition>
        <argsstring>(Range &amp;&amp;values)</argsstring>
        <name>when_all</name>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>values</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A range holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a future holding the same list of futures as has been passed to when_all.<itemizedlist>
<listitem><para>future&lt;Container&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>when_all</emphasis> where the input container is empty, returns a future with an empty container that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_all</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_all.hpp" line="72" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__all_8hpp_1a5487cfa0e100bffc9a9fbd49afbb7664" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>future&lt; tuple&lt; future&lt; T &gt;... &gt; &gt;</type>
        <definition>future&lt;tuple&lt;future&lt;T&gt;...&gt; &gt; hpx::when_all</definition>
        <argsstring>(T &amp;&amp;... futures)</argsstring>
        <name>when_all</name>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_all</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>when_all</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a future holding the same list of futures as has been passed to <emphasis>when_all</emphasis>.<itemizedlist>
<listitem><para>future&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;, future&lt;T2&gt;...&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</para></listitem><listitem><para>future&lt;tuple&lt;&gt;&gt; if <emphasis>when_all</emphasis> is called with zero arguments. The returned future will be initially ready.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_all</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_all.hpp" line="98" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__all_8hpp_1ab92c88e6a0d8c6632caa863f7ece9694" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
          <param>
            <type>typename Container</type>
            <defval>vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>future&lt; Container &gt;</type>
        <definition>future&lt;Container&gt; hpx::when_all_n</definition>
        <argsstring>(InputIter begin, std::size_t count)</argsstring>
        <name>when_all_n</name>
        <param>
          <type>InputIter</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_all_n</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_all_n</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of elements in the sequence starting at <emphasis>first</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a future holding the same list of futures as has been passed to <emphasis>when_all_n</emphasis>.<itemizedlist>
<listitem><para>future&lt;Container&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output vector will be the same as given by the input iterator.</para></listitem></itemizedlist>
</para></simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>This</parametername>
</parameternamelist>
<parameterdescription>
<para>function will throw errors which are encountered while setting up the requested operation only. Errors encountered while executing the operations delivering the results to be stored in the futures are reported through the futures themselves.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of hpx::exception.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_all.hpp" line="133" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__any_8hpp_1aa6c2d1fdea349e2a9937f249aa4d895a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_any</definition>
        <argsstring>(InputIter first, InputIter last, error_code &amp;ec=throws)</argsstring>
        <name>wait_any</name>
        <param>
          <type>InputIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_any</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_any</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_any</emphasis> returns after at least one future has become ready. All input futures are still valid after <emphasis>wait_any</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of <emphasis>hpx::exception</emphasis>.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_any.hpp" line="40" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__any_8hpp_1a2f6e1ea8b8e8c8641163dca6bd76a398" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_any</definition>
        <argsstring>(std::vector&lt; future&lt; R &gt;&gt; &amp;futures, error_code &amp;ec=throws)</argsstring>
        <name>wait_any</name>
        <param>
          <type>std::vector&lt; future&lt; R &gt;&gt; &amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A vector holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_any</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_any</emphasis> returns after at least one future has become ready. All input futures are still valid after <emphasis>wait_any</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of <emphasis>hpx::exception</emphasis>.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_any.hpp" line="64" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__any_8hpp_1a494d58af1e4c954cac20c0281e1000a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>std:;size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_any</definition>
        <argsstring>(std::array&lt; future&lt; R &gt;, N &gt; &amp;futures, error_code &amp;ec=throws)</argsstring>
        <name>wait_any</name>
        <param>
          <type>std::array&lt; future&lt; R &gt;, N &gt; &amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] Amn array holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_any</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_any</emphasis> returns after at least one future has become ready. All input futures are still valid after <emphasis>wait_any</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of <emphasis>hpx::exception</emphasis>.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_any.hpp" line="88" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__any_8hpp_1a753be8b612b525011128316b03a11a0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_any</definition>
        <argsstring>(error_code &amp;ec, T &amp;&amp;... futures)</argsstring>
        <name>wait_any</name>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
        </param>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>wait_any</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_any</emphasis> returns after at least one future has become ready. All input futures are still valid after <emphasis>wait_any</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of <emphasis>hpx::exception</emphasis>.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_any.hpp" line="112" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__any_8hpp_1a7643b830c016c4243d3510e6abbe8518" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_any</definition>
        <argsstring>(T &amp;&amp;... futures)</argsstring>
        <name>wait_any</name>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>wait_any</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_any</emphasis> returns after at least one future has become ready. All input futures are still valid after <emphasis>wait_any</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_any.hpp" line="128" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__any_8hpp_1a473595a452088ddf13454f952fc85909" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
        </templateparamlist>
        <type>InputIter</type>
        <definition>InputIter hpx::wait_any_n</definition>
        <argsstring>(InputIter first, std::size_t count, error_code &amp;ec=throws)</argsstring>
        <name>wait_any_n</name>
        <param>
          <type>InputIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_any_n</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_any_n</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of elements in the sequence starting at <emphasis>first</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_any_n</emphasis> returns after at least one future has become ready. All input futures are still valid after <emphasis>wait_any_n</emphasis> returns.</para></simplesect>
<simplesect kind="return"><para>The function <emphasis>wait_all_n</emphasis> will return an iterator referring to the first element in the input sequence after the last processed element.</para></simplesect>
<simplesect kind="note"><para>As long as <emphasis>ec</emphasis> is not pre-initialized to <emphasis>hpx::throws</emphasis> this function doesn&apos;t throw but returns the result code using the parameter <emphasis>ec</emphasis>. Otherwise it throws an instance of <emphasis>hpx::exception</emphasis>.</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_any.hpp" line="158" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__any_8hpp_1a39262d7122af673a49fe039cd8f860d9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
          <param>
            <type>typename Container</type>
            <defval>vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt; Container &gt; &gt;</type>
        <definition>future&lt;when_any_result&lt;Container&gt; &gt; hpx::when_any</definition>
        <argsstring>(InputIter first, InputIter last)</argsstring>
        <name>when_any</name>
        <param>
          <type>InputIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>InputIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_any</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_any</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref> holding the same list of futures as has been passed to when_any and an index pointing to a ready future.<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_any.hpp" line="48" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__any_8hpp_1a873832b1838b63f2532ddee810bd3999" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt; Range &gt; &gt;</type>
        <definition>future&lt;when_any_result&lt;Range&gt; &gt; hpx::when_any</definition>
        <argsstring>(Range &amp;values)</argsstring>
        <name>when_any</name>
        <param>
          <type>Range &amp;</type>
          <declname>values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>values</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A range holding an arbitrary amount of <emphasis>futures</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_any</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref> holding the same list of futures as has been passed to when_any and an index pointing to a ready future.<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_any.hpp" line="69" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__any_8hpp_1a30dd3855c03be0f67bd1f2a22f90db65" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt; tuple&lt; future&lt; T &gt;... &gt; &gt; &gt;</type>
        <definition>future&lt;when_any_result&lt;tuple&lt;future&lt;T&gt;...&gt; &gt; &gt; hpx::when_any</definition>
        <argsstring>(T &amp;&amp;... futures)</argsstring>
        <name>when_any</name>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_any</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>when_any</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref> holding the same list of futures as has been passed to when_any and an index pointing to a ready future..<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;...&gt;&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</para></listitem><listitem><para>future&lt;<ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt;tuple&lt;&gt;&gt;&gt; if <emphasis>when_any</emphasis> is called with zero arguments. The returned future will be initially ready. </para></listitem></itemizedlist>
</para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_any.hpp" line="92" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__any_8hpp_1a5ce49e380ca54cdfb5418f3b949121c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
          <param>
            <type>typename Container</type>
            <defval>vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt; Container &gt; &gt;</type>
        <definition>future&lt;when_any_result&lt;Container&gt; &gt; hpx::when_any_n</definition>
        <argsstring>(InputIter first, std::size_t count)</argsstring>
        <name>when_any_n</name>
        <param>
          <type>InputIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_any_n</emphasis> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_any_n</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of elements in the sequence starting at <emphasis>first</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref> holding the same list of futures as has been passed to when_any and an index pointing to a ready future.<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__any__result" kindref="compound">when_any_result</ref>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>None of the futures in the input sequence are invalidated. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_any.hpp" line="118" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__some_8hpp_1a3bdc4048a047990e555ed5cc4d907186" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
        </templateparamlist>
        <type>future&lt; vector&lt; future&lt; typename std::iterator_traits&lt; InputIter &gt;::value_type &gt; &gt; &gt;</type>
        <definition>future&lt;vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt; &gt; &gt; hpx::wait_some</definition>
        <argsstring>(std::size_t n, Iterator first, Iterator last, error_code &amp;ec=throws)</argsstring>
        <name>wait_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The future returned by the function <emphasis>wait_some</emphasis> becomes ready when at least <emphasis>n</emphasis> argument futures have become ready.</para></simplesect>
<simplesect kind="return"><para>Returns a future holding the same list of futures as has been passed to wait_some.<itemizedlist>
<listitem><para>future&lt;vector&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>wait_some</emphasis> where first == last, returns a future with an empty vector that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>wait_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_some.hpp" line="51" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__some_8hpp_1a5a9f799e2f9d3067a6eb0a50f56c5ff7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_some</definition>
        <argsstring>(std::size_t n, std::vector&lt; future&lt; R &gt;&gt; &amp;&amp;futures, error_code &amp;ec=throws)</argsstring>
        <name>wait_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::vector&lt; future&lt; R &gt;&gt; &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A vector holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_some</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after <emphasis>n</emphasis> futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>wait_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_some.hpp" line="78" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__some_8hpp_1a8197e0310ca56f286f76fd320d34d36b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>std::size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_some</definition>
        <argsstring>(std::size_t n, std::array&lt; future&lt; R &gt;, N &gt; &amp;&amp;futures, error_code &amp;ec=throws)</argsstring>
        <name>wait_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>std::array&lt; future&lt; R &gt;, N &gt; &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An array holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_some</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after <emphasis>n</emphasis> futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>wait_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_some.hpp" line="106" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__some_8hpp_1a889a1f42bc0fc5e4adcd480fb41ba7d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_some</definition>
        <argsstring>(std::size_t n, T &amp;&amp;... futures, error_code &amp;ec=throws)</argsstring>
        <name>wait_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>wait_some</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after <emphasis>n</emphasis> futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns.</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>wait_some</emphasis> where first == last, returns a future with an empty vector that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>wait_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_some.hpp" line="136" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__some_8hpp_1aa0b7f68e78d76b35853777b2fd736cd6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
        </templateparamlist>
        <type>InputIter</type>
        <definition>InputIter hpx::wait_some_n</definition>
        <argsstring>(std::size_t n, Iterator first, std::size_t count, error_code &amp;ec=throws)</argsstring>
        <name>wait_some_n</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_some_n</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of elements in the sequence starting at <emphasis>first</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The function <emphasis>wait_all</emphasis> returns after <emphasis>n</emphasis> futures have become ready. All input futures are still valid after <emphasis>wait_all</emphasis> returns.</para></simplesect>
<simplesect kind="return"><para>This function returns an Iterator referring to the first element after the last processed input element.</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>wait_some_n</emphasis> where count == 0, returns a future with the same elements as the arguments that is immediately ready. Possibly none of the futures in that vector are ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>wait_some_n</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_some.hpp" line="172" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__some_8hpp_1a4bd1040a6422fc4653e90cdbb56ac8a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
          <param>
            <type>typename Container</type>
            <defval>vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt; Container &gt; &gt;</type>
        <definition>future&lt;when_some_result&lt;Container&gt; &gt; hpx::when_some</definition>
        <argsstring>(std::size_t n, Iterator first, Iterator last, error_code &amp;ec=throws)</argsstring>
        <name>when_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>last</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The future returned by the function <emphasis>when_some</emphasis> becomes ready when at least <emphasis>n</emphasis> argument futures have become ready.</para></simplesect>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref> holding the same list of futures as has been passed to when_some and indices pointing to ready futures.<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>when_some</emphasis> where first == last, returns a future with an empty container that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_some.hpp" line="68" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__some_8hpp_1a9f139b5deacfac09f271f5e10e7fb9e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Range</type>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt; Range &gt; &gt;</type>
        <definition>future&lt;when_some_result&lt;Range&gt; &gt; hpx::when_some</definition>
        <argsstring>(std::size_t n, Range &amp;&amp;futures, error_code &amp;ec=throws)</argsstring>
        <name>when_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>Range &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] A container holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_some</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The future returned by the function <emphasis>when_some</emphasis> becomes ready when at least <emphasis>n</emphasis> argument futures have become ready.</para></simplesect>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref> holding the same list of futures as has been passed to when_some and indices pointing to ready futures.<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_some.hpp" line="104" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__some_8hpp_1abe15ece162ff9c9295bf747419457372" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt; tuple&lt; future&lt; T &gt;... &gt; &gt; &gt;</type>
        <definition>future&lt;when_some_result&lt;tuple&lt;future&lt;T&gt;...&gt; &gt; &gt; hpx::when_some</definition>
        <argsstring>(std::size_t n, error_code &amp;ec, T &amp;&amp;... futures)</argsstring>
        <name>when_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
        </param>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>when_some</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The future returned by the function <emphasis>when_some</emphasis> becomes ready when at least <emphasis>n</emphasis> argument futures have become ready.</para></simplesect>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref> holding the same list of futures as has been passed to when_some and an index pointing to a ready future..<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;...&gt;&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</para></listitem><listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;tuple&lt;&gt;&gt;&gt; if <emphasis>when_some</emphasis> is called with zero arguments. The returned future will be initially ready.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_some.hpp" line="143" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__some_8hpp_1aab33ab749e355cd660d4927dca64bb94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt; tuple&lt; future&lt; T &gt;... &gt; &gt; &gt;</type>
        <definition>future&lt;when_some_result&lt;tuple&lt;future&lt;T&gt;...&gt; &gt; &gt; hpx::when_some</definition>
        <argsstring>(std::size_t n, T &amp;&amp;... futures)</argsstring>
        <name>when_some</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_some</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>when_some</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The future returned by the function <emphasis>when_some</emphasis> becomes ready when at least <emphasis>n</emphasis> argument futures have become ready.</para></simplesect>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref> holding the same list of futures as has been passed to when_some and an index pointing to a ready future..<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;...&gt;&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</para></listitem><listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;tuple&lt;&gt;&gt;&gt; if <emphasis>when_some</emphasis> is called with zero arguments. The returned future will be initially ready.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_some</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_some.hpp" line="178" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__some_8hpp_1a26b0d20e428ca92acf91daa131116991" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename InputIter</type>
          </param>
          <param>
            <type>typename Container</type>
            <defval>vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>future&lt; <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt; Container &gt; &gt;</type>
        <definition>future&lt;when_some_result&lt;Container&gt; &gt; hpx::when_some_n</definition>
        <argsstring>(std::size_t n, Iterator first, std::size_t count, error_code &amp;ec=throws)</argsstring>
        <name>when_some_n</name>
        <param>
          <type>std::size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>error_code &amp;</type>
          <declname>ec</declname>
          <defval>throws</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_some_n</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>when_all</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>[in] The number of elements in the sequence starting at <emphasis>first</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ec</parametername>
</parameternamelist>
<parameterdescription>
<para>[in,out] this represents the error status on exit, if this is pre-initialized to <emphasis>hpx::throws</emphasis> the function will throw on error instead.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The future returned by the function <emphasis>when_some_n</emphasis> becomes ready when at least <emphasis>n</emphasis> argument futures have become ready.</para></simplesect>
<simplesect kind="return"><para>Returns a <ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref> holding the same list of futures as has been passed to when_some and indices pointing to ready futures.<itemizedlist>
<listitem><para>future&lt;<ref refid="structhpx_1_1when__some__result" kindref="compound">when_some_result</ref>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="note"><para>Calling this version of <emphasis>when_some_n</emphasis> where count == 0, returns a future with the same elements as the arguments that is immediately ready. Possibly none of the futures in that container are ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <emphasis>when_some_n</emphasis> will not throw an exception, but the futures held in the output collection may. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_some.hpp" line="221" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__each_8hpp_1ac6b482038537407a111c5cd1450e7da3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Future</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_each</definition>
        <argsstring>(F &amp;&amp;f, std::vector&lt; Future &gt; &amp;&amp;futures)</argsstring>
        <name>wait_each</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::vector&lt; Future &gt; &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready. <emphasis>wait_each</emphasis> returns after all futures have been become ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_each.hpp" line="38" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__each_8hpp_1a1f84c6d619603f1f006332b38282827b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_each</definition>
        <argsstring>(F &amp;&amp;f, Iterator begin, Iterator end)</argsstring>
        <name>wait_each</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready. <emphasis>wait_each</emphasis> returns after all futures have been become ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_each.hpp" line="65" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__each_8hpp_1ae4f21fe90a34bf80db58da41f1e1c927" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename ...</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_each</definition>
        <argsstring>(F &amp;&amp;f, T &amp;&amp;... futures)</argsstring>
        <name>wait_each</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready. <emphasis>wait_each</emphasis> returns after all futures have been become ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>wait_each</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_each.hpp" line="89" column="1"/>
      </memberdef>
      <memberdef kind="function" id="wait__each_8hpp_1aa9dbb6eec3a4793006888ce9319cef7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void hpx::wait_each_n</definition>
        <argsstring>(F &amp;&amp;f, Iterator begin, std::size_t count)</argsstring>
        <name>wait_each_n</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>wait_each</emphasis> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each_n</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of elements in the sequence starting at <emphasis>first</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/wait_each.hpp" line="114" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__each_8hpp_1a28891e415cdd55013fc8bfb772ba1033" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Future</type>
          </param>
        </templateparamlist>
        <type>future&lt; void &gt;</type>
        <definition>future&lt;void&gt; hpx::when_each</definition>
        <argsstring>(F &amp;&amp;f, std::vector&lt; Future &gt; &amp;&amp;futures)</argsstring>
        <name>when_each</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::vector&lt; Future &gt; &amp;&amp;</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready.</para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>A vector holding an arbitrary amount of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection.</para></simplesect>
<simplesect kind="return"><para>Returns a future representing the event of all input futures being ready. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_each.hpp" line="41" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__each_8hpp_1aa6092f39d3499b082417824545bab9c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type>future&lt; Iterator &gt;</type>
        <definition>future&lt;Iterator&gt; hpx::when_each</definition>
        <argsstring>(F &amp;&amp;f, Iterator begin, Iterator end)</argsstring>
        <name>when_each</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>end</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the last element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection.</para></simplesect>
<simplesect kind="return"><para>Returns a future representing the event of all input futures being ready. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_each.hpp" line="70" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__each_8hpp_1a19551f2294b4e5d05601873845e00537" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Ts</declname>
            <defname>Ts</defname>
          </param>
        </templateparamlist>
        <type>future&lt; void &gt;</type>
        <definition>future&lt;void&gt; hpx::when_each</definition>
        <argsstring>(F &amp;&amp;f, Ts &amp;&amp;... futures)</argsstring>
        <name>when_each</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Ts &amp;&amp;...</type>
          <declname>futures</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>futures</parametername>
</parameternamelist>
<parameterdescription>
<para>An arbitrary number of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects, possibly holding different types for which <emphasis>wait_each</emphasis> should wait.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection.</para></simplesect>
<simplesect kind="return"><para>Returns a future representing the event of all input futures being ready. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_each.hpp" line="96" column="1"/>
      </memberdef>
      <memberdef kind="function" id="when__each_8hpp_1a3ffc42990d742339663bdcca1785a9b8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Iterator</type>
          </param>
        </templateparamlist>
        <type>future&lt; Iterator &gt;</type>
        <definition>future&lt;Iterator&gt; hpx::when_each_n</definition>
        <argsstring>(F &amp;&amp;f, Iterator begin, std::size_t count)</argsstring>
        <name>when_each_n</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Iterator</type>
          <declname>begin</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The function <emphasis>when_each</emphasis> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function which will be called for each of the input futures once the future has become ready. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>begin</parametername>
</parameternamelist>
<parameterdescription>
<para>The iterator pointing to the first element of a sequence of <emphasis>future</emphasis> or <emphasis>shared_future</emphasis> objects for which <emphasis>wait_each_n</emphasis> should wait. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of elements in the sequence starting at <emphasis>first</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <emphasis>future</emphasis> to be processed or a type that <emphasis>std::size_t</emphasis> is implicitly convertible to as the first parameter and the <emphasis>future</emphasis> as the second parameter. The first parameter will correspond to the index of the current <emphasis>future</emphasis> in the collection.</para></simplesect>
<simplesect kind="return"><para>Returns a future holding the iterator pointing to the first element after the last one. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="hpx/lcos/when_each.hpp" line="124" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="hpx/hpx_init.hpp" line="52" column="1"/>
  </compounddef>
</doxygen>
