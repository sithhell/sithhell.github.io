<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacehpx_1_1program__options" kind="namespace" language="C++">
    <compoundname>hpx::program_options</compoundname>
    <innerclass refid="classhpx_1_1program__options_1_1abstract__variables__map" prot="public">hpx::program_options::abstract_variables_map</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1ambiguous__option" prot="public">hpx::program_options::ambiguous_option</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1basic__command__line__parser" prot="public">hpx::program_options::basic_command_line_parser</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1basic__option" prot="public">hpx::program_options::basic_option</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1basic__parsed__options" prot="public">hpx::program_options::basic_parsed_options</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1basic__parsed__options_3_01wchar__t_01_4" prot="public">hpx::program_options::basic_parsed_options&lt; wchar_t &gt;</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1duplicate__option__error" prot="public">hpx::program_options::duplicate_option_error</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1environment__iterator" prot="public">hpx::program_options::environment_iterator</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1eof__iterator" prot="public">hpx::program_options::eof_iterator</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1error" prot="public">hpx::program_options::error</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1error__with__no__option__name" prot="public">hpx::program_options::error_with_no_option_name</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1error__with__option__name" prot="public">hpx::program_options::error_with_option_name</innerclass>
    <innerclass refid="structhpx_1_1program__options_1_1force__linking__helper" prot="public">hpx::program_options::force_linking_helper</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1invalid__bool__value" prot="public">hpx::program_options::invalid_bool_value</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1invalid__command__line__style" prot="public">hpx::program_options::invalid_command_line_style</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1invalid__command__line__syntax" prot="public">hpx::program_options::invalid_command_line_syntax</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1invalid__config__file__syntax" prot="public">hpx::program_options::invalid_config_file_syntax</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1invalid__option__value" prot="public">hpx::program_options::invalid_option_value</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1invalid__syntax" prot="public">hpx::program_options::invalid_syntax</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1multiple__occurrences" prot="public">hpx::program_options::multiple_occurrences</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1multiple__values" prot="public">hpx::program_options::multiple_values</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1option__description" prot="public">hpx::program_options::option_description</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1options__description" prot="public">hpx::program_options::options_description</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1options__description__easy__init" prot="public">hpx::program_options::options_description_easy_init</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1positional__options__description" prot="public">hpx::program_options::positional_options_description</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1reading__file" prot="public">hpx::program_options::reading_file</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1required__option" prot="public">hpx::program_options::required_option</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1too__many__positional__options__error" prot="public">hpx::program_options::too_many_positional_options_error</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1typed__value" prot="public">hpx::program_options::typed_value</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1typed__value__base" prot="public">hpx::program_options::typed_value_base</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1unknown__option" prot="public">hpx::program_options::unknown_option</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1untyped__value" prot="public">hpx::program_options::untyped_value</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1validation__error" prot="public">hpx::program_options::validation_error</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1value__semantic" prot="public">hpx::program_options::value_semantic</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1value__semantic__codecvt__helper" prot="public">hpx::program_options::value_semantic_codecvt_helper</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1value__semantic__codecvt__helper_3_01char_01_4" prot="public">hpx::program_options::value_semantic_codecvt_helper&lt; char &gt;</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1value__semantic__codecvt__helper_3_01wchar__t_01_4" prot="public">hpx::program_options::value_semantic_codecvt_helper&lt; wchar_t &gt;</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1variable__value" prot="public">hpx::program_options::variable_value</innerclass>
    <innerclass refid="classhpx_1_1program__options_1_1variables__map" prot="public">hpx::program_options::variables_map</innerclass>
    <innernamespace refid="namespacehpx_1_1program__options_1_1command__line__style">hpx::program_options::command_line_style</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="parsers_8hpp_1a15d30b8fc42a3ea5f2e971e66941747a" prot="public" static="no">
        <name>collect_unrecognized_mode</name>
        <enumvalue id="parsers_8hpp_1a15d30b8fc42a3ea5f2e971e66941747aad873f121a0663701523cec10cee64706" prot="public">
          <name>include_positional</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="parsers_8hpp_1a15d30b8fc42a3ea5f2e971e66941747aac49ce00f2d05fca224e17a79aed5540f" prot="public">
          <name>exclude_positional</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Controls if the &apos;collect_unregistered&apos; function should include positional options, or not. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="235" column="1" bodyfile="libs/program_options/include/hpx/program_options/parsers.hpp" bodystart="234" bodyend="238"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="parsers_8hpp_1a4d2f969f0e32843726dcd758f3c1584c" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt;</type>
        <definition>using hpx::program_options::parsed_options = typedef basic_parsed_options&lt;char&gt;</definition>
        <argsstring></argsstring>
        <name>parsed_options</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="130" column="1" bodyfile="libs/program_options/include/hpx/program_options/parsers.hpp" bodystart="130" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsers_8hpp_1a666f6c8eed28b074b389dacedb2f6d9d" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; wchar_t &gt;</type>
        <definition>using hpx::program_options::wparsed_options = typedef basic_parsed_options&lt;wchar_t&gt;</definition>
        <argsstring></argsstring>
        <name>wparsed_options</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="131" column="1" bodyfile="libs/program_options/include/hpx/program_options/parsers.hpp" bodystart="131" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsers_8hpp_1ae822715d125eab0aaf663dce22b15c09" prot="public" static="no">
        <type>std::function&lt; std::pair&lt; std::string, std::string &gt;(const std::string &amp;)&gt;</type>
        <definition>using hpx::program_options::ext_parser = typedef std::function&lt;std::pair&lt;std::string, std::string&gt;(const std::string&amp;)&gt;</definition>
        <argsstring></argsstring>
        <name>ext_parser</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Augments <ref refid="classhpx_1_1program__options_1_1basic__parsed__options_3_01wchar__t_01_4" kindref="compound">basic_parsed_options&lt;wchar_t&gt;</ref> with conversion from &apos;parsed_options&apos; </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="136" column="1" bodyfile="libs/program_options/include/hpx/program_options/parsers.hpp" bodystart="137" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsers_8hpp_1a8e4159d527476ba39b0e30e1e63811d8" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__command__line__parser" kindref="compound">basic_command_line_parser</ref>&lt; char &gt;</type>
        <definition>using hpx::program_options::command_line_parser = typedef basic_command_line_parser&lt;char&gt;</definition>
        <argsstring></argsstring>
        <name>command_line_parser</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="201" column="1" bodyfile="libs/program_options/include/hpx/program_options/parsers.hpp" bodystart="201" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="parsers_8hpp_1a527a6422646a2d27081da0560a471ed2" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__command__line__parser" kindref="compound">basic_command_line_parser</ref>&lt; wchar_t &gt;</type>
        <definition>using hpx::program_options::wcommand_line_parser = typedef basic_command_line_parser&lt;wchar_t&gt;</definition>
        <argsstring></argsstring>
        <name>wcommand_line_parser</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="202" column="1" bodyfile="libs/program_options/include/hpx/program_options/parsers.hpp" bodystart="202" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1a3d8d61f4d7010020a570cbf287259e14" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt;(*)(<ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> const  &amp;, char const  *)</type>
        <definition>using hpx::program_options::parse_environment1_type = typedef basic_parsed_options&lt;char&gt; (*)( options_description const&amp;, char const*)</definition>
        <argsstring></argsstring>
        <name>parse_environment1_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="31" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1af722cb45acfd00b0359d62b99826bdad" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt;(*)(<ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> const  &amp;, std::function&lt; std::string(std::string)&gt; const  &amp;)</type>
        <definition>using hpx::program_options::parse_environment2_type = typedef basic_parsed_options&lt;char&gt; (*)( options_description const&amp;, std::function&lt;std::string(std::string)&gt; const&amp;)</definition>
        <argsstring></argsstring>
        <name>parse_environment2_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="33" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1a72da4a66ec9ce1c97005046fd89ce814" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt;(*)(<ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> const  &amp;, std::string const  &amp;)</type>
        <definition>using hpx::program_options::parse_environment3_type = typedef basic_parsed_options&lt;char&gt; (*)( options_description const&amp;, std::string const&amp;)</definition>
        <argsstring></argsstring>
        <name>parse_environment3_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="36" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1aa4f794c9d0bef1c688e1780b4928fb81" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt;(*)(char const  *, <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> const  &amp;, bool)</type>
        <definition>using hpx::program_options::parse_config_file_char1_type = typedef basic_parsed_options&lt;char&gt; (*)( char const*, options_description const&amp;, bool)</definition>
        <argsstring></argsstring>
        <name>parse_config_file_char1_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="39" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1a40ef9a82c2506431cd2693b243029c72" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt;(*)(std::basic_istream&lt; char, struct std::char_traits&lt; char &gt; &gt; &amp;, <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> const  &amp;, bool)</type>
        <definition>using hpx::program_options::parse_config_file_char2_type = typedef basic_parsed_options&lt;char&gt; (*)( std::basic_istream&lt;char, struct std::char_traits&lt;char&gt; &gt;&amp;, options_description const&amp;, bool)</definition>
        <argsstring></argsstring>
        <name>parse_config_file_char2_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="41" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="43" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1a5aa410d6c6c3f0eb670f3e2f2531808a" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; wchar_t &gt;(*)(std::basic_istream&lt; wchar_t, struct std::char_traits&lt; wchar_t &gt; &gt; &amp;, <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> const  &amp;, bool)</type>
        <definition>using hpx::program_options::parse_config_file_wchar1_type = typedef basic_parsed_options&lt;wchar_t&gt; (*)( std::basic_istream&lt;wchar_t, struct std::char_traits&lt;wchar_t&gt; &gt;&amp;, options_description const&amp;, bool)</definition>
        <argsstring></argsstring>
        <name>parse_config_file_wchar1_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="45" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="force__linking_8hpp_1ad49a09b61d37485ccaf38617c082c600" prot="public" static="no">
        <type>std::vector&lt; std::string &gt;(*)(std::string const  &amp;, std::string const  &amp;, std::string const  &amp;, std::string const  &amp;)</type>
        <definition>using hpx::program_options::split_unix_type = typedef std::vector&lt;std::string&gt; (*)(std::string const&amp;, std::string const&amp;, std::string const&amp;, std::string const&amp;)</definition>
        <argsstring></argsstring>
        <name>split_unix_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="49" column="1" bodyfile="libs/program_options/include/hpx/program_options/force_linking.hpp" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="option_8hpp_1aa725e8d1bc19bfcd27cad337b8204b95" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__option" kindref="compound">basic_option</ref>&lt; char &gt;</type>
        <definition>using hpx::program_options::option = typedef basic_option&lt;char&gt;</definition>
        <argsstring></argsstring>
        <name>option</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/option.hpp" line="86" column="1" bodyfile="libs/program_options/include/hpx/program_options/option.hpp" bodystart="86" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="option_8hpp_1a79d7335c5f4bce8aa3f892fa42d12460" prot="public" static="no">
        <type><ref refid="classhpx_1_1program__options_1_1basic__option" kindref="compound">basic_option</ref>&lt; wchar_t &gt;</type>
        <definition>using hpx::program_options::woption = typedef basic_option&lt;wchar_t&gt;</definition>
        <argsstring></argsstring>
        <name>woption</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/option.hpp" line="87" column="1" bodyfile="libs/program_options/include/hpx/program_options/option.hpp" bodystart="87" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="config_8hpp_1a92f36efed58e5422a70f22a05517ed2f" prot="public" static="no">
        <type>hpx::util::any_nonser</type>
        <definition>using hpx::program_options::any = typedef hpx::util::any_nonser</definition>
        <argsstring></argsstring>
        <name>any</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/config.hpp" line="46" column="1" bodyfile="libs/program_options/include/hpx/program_options/config.hpp" bodystart="46" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="config_8hpp_1a367a6dff288d082eb650ab8d13daa47e" prot="public" static="no">
        <type>hpx::util::optional&lt; T &gt;</type>
        <definition>using hpx::program_options::optional = typedef hpx::util::optional&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>optional</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/config.hpp" line="49" column="1" bodyfile="libs/program_options/include/hpx/program_options/config.hpp" bodystart="49" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="errors_8hpp_1a41ee933a4ce1de27dd249ad539dd28c6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string hpx::program_options::strip_prefixes</definition>
        <argsstring>(const std::string &amp;text)</argsstring>
        <name>strip_prefixes</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>text</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/errors.hpp" line="50" column="1" bodyfile="libs/program_options/include/hpx/program_options/errors.hpp" bodystart="50" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1a2a30511c1ea40286b3322b33674c2546" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Char</type>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; Char &gt;</type>
        <definition>basic_parsed_options&lt;Char&gt; hpx::program_options::parse_command_line</definition>
        <argsstring>(int argc, const Char *const argv[], const options_description &amp;, int style=0, std::function&lt; std::pair&lt; std::string, std::string &gt;(const std::string &amp;)&gt; ext=ext_parser())</argsstring>
        <name>parse_command_line</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>const Char *const</type>
          <declname>argv</declname>
          <array>[]</array>
        </param>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> &amp;</type>
        </param>
        <param>
          <type>int</type>
          <declname>style</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>std::function&lt; std::pair&lt; std::string, std::string &gt;(const std::string &amp;)&gt;</type>
          <declname>ext</declname>
          <defval>ext_parser()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates instance of &apos;command_line_parser&apos;, passes parameters to it, and returns the result of calling the &apos;run&apos; method. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="208" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1a9eea8e48afe44f99b38d1b350180fd1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Char</type>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; Char &gt;</type>
        <definition>basic_parsed_options&lt;Char&gt; hpx::program_options::parse_config_file</definition>
        <argsstring>(std::basic_istream&lt; Char &gt; &amp;, const options_description &amp;, bool allow_unregistered=false)</argsstring>
        <name>parse_config_file</name>
        <param>
          <type>std::basic_istream&lt; Char &gt; &amp;</type>
        </param>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> &amp;</type>
        </param>
        <param>
          <type>bool</type>
          <declname>allow_unregistered</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a config file.</para><para>Read from given stream. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="218" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1a58bcf7c4438890df27a72161bb401125" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Char</type>
            <defval>char</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; Char &gt;</type>
        <definition>basic_parsed_options&lt;Char&gt; hpx::program_options::parse_config_file</definition>
        <argsstring>(const char *filename, const options_description &amp;, bool allow_unregistered=false)</argsstring>
        <name>parse_config_file</name>
        <param>
          <type>const char *</type>
          <declname>filename</declname>
        </param>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> &amp;</type>
        </param>
        <param>
          <type>bool</type>
          <declname>allow_unregistered</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a config file.</para><para>Read from file with the given name. The character type is passed to the file stream. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="228" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1aae21382b1f6f2113449a5a535bedeee2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Char</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; std::basic_string&lt; Char &gt; &gt;</type>
        <definition>std::vector&lt;std::basic_string&lt;Char&gt; &gt; hpx::program_options::collect_unrecognized</definition>
        <argsstring>(const std::vector&lt; basic_option&lt; Char &gt;&gt; &amp;options, enum collect_unrecognized_mode mode)</argsstring>
        <name>collect_unrecognized</name>
        <param>
          <type>const std::vector&lt; <ref refid="classhpx_1_1program__options_1_1basic__option" kindref="compound">basic_option</ref>&lt; Char &gt;&gt; &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>enum collect_unrecognized_mode</type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Collects the original tokens for all named options with &apos;unregistered&apos; flag set. If &apos;mode&apos; is &apos;include_positional&apos; also collects all positional options. Returns the vector of origianl tokens for all collected options. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="247" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1a81bfe109b65ca5040a79e387be8c8650" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">parsed_options</ref></type>
        <definition>parsed_options hpx::program_options::parse_environment</definition>
        <argsstring>(const options_description &amp;, const std::function&lt; std::string(std::string)&gt; &amp;name_mapper)</argsstring>
        <name>parse_environment</name>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> &amp;</type>
        </param>
        <param>
          <type>const std::function&lt; std::string(std::string)&gt; &amp;</type>
          <declname>name_mapper</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse environment.</para><para>For each environment variable, the &apos;name_mapper&apos; function is called to obtain the option name. If it returns empty string, the variable is ignored.</para><para>This is done since naming of environment variables is typically different from the naming of command line options. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="260" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1ab504469fa2d7c5b5a785c2db91500482" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">parsed_options</ref></type>
        <definition>parsed_options hpx::program_options::parse_environment</definition>
        <argsstring>(const options_description &amp;, const std::string &amp;prefix)</argsstring>
        <name>parse_environment</name>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> &amp;</type>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>prefix</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse environment.</para><para>Takes all environment variables which start with &apos;prefix&apos;. The option name is obtained from variable name by removing the prefix and converting the remaining string into lower case. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="269" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1ad83e695357762f70cc372d7c03ab1496" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">parsed_options</ref></type>
        <definition>parsed_options hpx::program_options::parse_environment</definition>
        <argsstring>(const options_description &amp;, const char *prefix)</argsstring>
        <name>parse_environment</name>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1options__description" kindref="compound">options_description</ref> &amp;</type>
        </param>
        <param>
          <type>const char *</type>
          <declname>prefix</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. This function exists to resolve ambiguity between the two above functions when second argument is of &apos;char*&apos; type. There&apos;s implicit conversion to both std::function and string. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="277" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1a66966d1fc76b4ad3753e6ec05d4bd236" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>std::vector&lt;std::string&gt; hpx::program_options::split_unix</definition>
        <argsstring>(const std::string &amp;cmdline, const std::string &amp;seperator=&quot; \, const std::string &amp;quote=&quot;&apos;\&quot;, const std::string &amp;escape=&quot;\&quot;)</argsstring>
        <name>split_unix</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>cmdline</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Splits a given string to a collection of single strings which can be passed to command_line_parser. The second parameter is used to specify a collection of possible seperator chars used for splitting. The seperator is defaulted to space &quot; &quot;. Splitting is done in a unix style way, with respect to quotes &apos;&quot;&apos; and escape characters &apos;\&apos; </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="287" column="1"/>
      </memberdef>
      <memberdef kind="function" id="parsers_8hpp_1a95104facc836ca479b21d3d7265587e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::wstring &gt;</type>
        <definition>std::vector&lt;std::wstring&gt; hpx::program_options::split_unix</definition>
        <argsstring>(const std::wstring &amp;cmdline, const std::wstring &amp;seperator=L&quot; \, const std::wstring &amp;quote=L&quot;&apos;\&quot;, const std::wstring &amp;escape=L&quot;\&quot;)</argsstring>
        <name>split_unix</name>
        <param>
          <type>const std::wstring &amp;</type>
          <declname>cmdline</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/parsers.hpp" line="292" column="1"/>
      </memberdef>
      <memberdef kind="function" id="value__semantic_8hpp_1a763adfd4791af64f81bfa23b82e991a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1typed__value" kindref="compound">typed_value</ref>&lt; T &gt; *</type>
        <definition>typed_value&lt;T&gt;* hpx::program_options::value</definition>
        <argsstring>()</argsstring>
        <name>value</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a typed_value&lt;T&gt; instance. This function is the primary method to create <ref refid="classhpx_1_1program__options_1_1value__semantic" kindref="compound">value_semantic</ref> instance for a specific type, which can later be passed to &apos;<ref refid="classhpx_1_1program__options_1_1option__description" kindref="compound">option_description</ref>&apos; constructor. The second overload is used when it&apos;s additionally desired to store the value of option into program variable. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/value_semantic.hpp" line="447" column="1"/>
      </memberdef>
      <memberdef kind="function" id="value__semantic_8hpp_1a28c84dc5904bc9b57ff6f06a957c8b33" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1typed__value" kindref="compound">typed_value</ref>&lt; T &gt; *</type>
        <definition>typed_value&lt;T&gt;* hpx::program_options::value</definition>
        <argsstring>(T *v)</argsstring>
        <name>value</name>
        <param>
          <type>T *</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/value_semantic.hpp" line="452" column="1"/>
      </memberdef>
      <memberdef kind="function" id="value__semantic_8hpp_1a9dac3fe85c78675b59bb24e8bd994aa6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1typed__value" kindref="compound">typed_value</ref>&lt; T, wchar_t &gt; *</type>
        <definition>typed_value&lt;T, wchar_t&gt;* hpx::program_options::wvalue</definition>
        <argsstring>()</argsstring>
        <name>wvalue</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a typed_value&lt;T&gt; instance. This function is the primary method to create <ref refid="classhpx_1_1program__options_1_1value__semantic" kindref="compound">value_semantic</ref> instance for a specific type, which can later be passed to &apos;<ref refid="classhpx_1_1program__options_1_1option__description" kindref="compound">option_description</ref>&apos; constructor. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/value_semantic.hpp" line="459" column="1"/>
      </memberdef>
      <memberdef kind="function" id="value__semantic_8hpp_1a686f4190d4bd4a5b10e616babf345577" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classhpx_1_1program__options_1_1typed__value" kindref="compound">typed_value</ref>&lt; T, wchar_t &gt; *</type>
        <definition>typed_value&lt;T, wchar_t&gt;* hpx::program_options::wvalue</definition>
        <argsstring>(T *v)</argsstring>
        <name>wvalue</name>
        <param>
          <type>T *</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/value_semantic.hpp" line="464" column="1"/>
      </memberdef>
      <memberdef kind="function" id="value__semantic_8hpp_1afd021457e0756190149c5d71a6163508" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classhpx_1_1program__options_1_1typed__value" kindref="compound">typed_value</ref>&lt; bool &gt; *</type>
        <definition>typed_value&lt;bool&gt;* hpx::program_options::bool_switch</definition>
        <argsstring>()</argsstring>
        <name>bool_switch</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Works the same way as the &apos;value&lt;bool&gt;&apos; function, but the created <ref refid="classhpx_1_1program__options_1_1value__semantic" kindref="compound">value_semantic</ref> won&apos;t accept any explicit value. So, if the option is present on the command line, the value will be &apos;true&apos;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/value_semantic.hpp" line="470" column="1"/>
      </memberdef>
      <memberdef kind="function" id="value__semantic_8hpp_1a95fb1334a75504584992b69c6565e3a8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classhpx_1_1program__options_1_1typed__value" kindref="compound">typed_value</ref>&lt; bool &gt; *</type>
        <definition>typed_value&lt;bool&gt;* hpx::program_options::bool_switch</definition>
        <argsstring>(bool *v)</argsstring>
        <name>bool_switch</name>
        <param>
          <type>bool *</type>
          <declname>v</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/value_semantic.hpp" line="474" column="1"/>
      </memberdef>
      <memberdef kind="function" id="force__linking_8hpp_1ac5350f095dd8aee49c4415a09c546423" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structhpx_1_1program__options_1_1force__linking__helper" kindref="compound">force_linking_helper</ref> &amp;</type>
        <definition>force_linking_helper&amp; hpx::program_options::force_linking</definition>
        <argsstring>()</argsstring>
        <name>force_linking</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/force_linking.hpp" line="66" column="1"/>
      </memberdef>
      <memberdef kind="function" id="variables__map_8hpp_1ae578dbcce43fa844ebd290098d8b2665" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::program_options::store</definition>
        <argsstring>(const basic_parsed_options&lt; char &gt; &amp;options, variables_map &amp;m, bool utf8=false)</argsstring>
        <name>store</name>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; char &gt; &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classhpx_1_1program__options_1_1variables__map" kindref="compound">variables_map</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>utf8</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Stores in &apos;m&apos; all options that are defined in &apos;options&apos;. If &apos;m&apos; already has a non-defaulted value of an option, that value is not changed, even if &apos;options&apos; specify some value. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/variables_map.hpp" line="56" column="1"/>
      </memberdef>
      <memberdef kind="function" id="variables__map_8hpp_1a2efabae30e16de10e3fbca8c2212c4ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::program_options::store</definition>
        <argsstring>(const basic_parsed_options&lt; wchar_t &gt; &amp;options, variables_map &amp;m)</argsstring>
        <name>store</name>
        <param>
          <type>const <ref refid="classhpx_1_1program__options_1_1basic__parsed__options" kindref="compound">basic_parsed_options</ref>&lt; wchar_t &gt; &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type><ref refid="classhpx_1_1program__options_1_1variables__map" kindref="compound">variables_map</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Stores in &apos;m&apos; all options that are defined in &apos;options&apos;. If &apos;m&apos; already has a non-defaulted value of an option, that value is not changed, even if &apos;options&apos; specify some value. This is wide character variant. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/variables_map.hpp" line="65" column="1"/>
      </memberdef>
      <memberdef kind="function" id="variables__map_8hpp_1aa3b77716849f8d13a4ecef640a06d2ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void hpx::program_options::notify</definition>
        <argsstring>(variables_map &amp;m)</argsstring>
        <name>notify</name>
        <param>
          <type><ref refid="classhpx_1_1program__options_1_1variables__map" kindref="compound">variables_map</ref> &amp;</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Runs all &apos;notify&apos; function for options in &apos;m&apos;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/program_options/include/hpx/program_options/variables_map.hpp" line="68" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="libs/program_options/include/hpx/program_options/cmdline.hpp" line="26" column="1"/>
  </compounddef>
</doxygen>
