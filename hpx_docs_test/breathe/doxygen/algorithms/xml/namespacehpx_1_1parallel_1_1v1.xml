<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="namespacehpx_1_1parallel_1_1v1" kind="namespace" language="C++">
    <compoundname>hpx::parallel::v1</compoundname>
      <sectiondef kind="func">
      <memberdef kind="function" id="container__algorithms_2generate_8hpp_1aed290ad93f522e69befe1628b71f4e8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::generate</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f)</argsstring>
        <name>generate</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assign each element in range [first, last) a value generated by the given function object f</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>distance(first, last)</emphasis> invocations of <emphasis>f</emphasis> and assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>generator function that will be called. signature of function should be equivalent to the following: <programlisting><codeline><highlight class="normal">Ret<sp/>fun();</highlight></codeline>
</programlisting> <linebreak/>
 The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>generate</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>generate</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/generate.hpp" line="81" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/generate.hpp" bodystart="81" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2move_8hpp_1ad742fd8240fc6c11325e9b6534eef9ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::move</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest)</argsstring>
        <name>move</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Moves the elements in the range <emphasis>rng</emphasis> to another range beginning at <emphasis>dest</emphasis>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</para><para><simplesect kind="note"><para>Complexity: Performs exactly std::distance(begin(rng), end(rng)) assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>move</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</emphasis>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</emphasis>, tag::out(FwdIter2)&gt; otherwise. The <emphasis>move</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element moved. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/move.hpp" line="83" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/move.hpp" bodystart="83" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2fill_8hpp_1a84a9d0b04c5eaffaf3debbf7b5a2391f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy&gt;::type hpx::parallel::v1::fill</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, T value)</argsstring>
        <name>fill</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns the given value to the elements in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be assigned (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be assigned.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>fill</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>fill</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>fill</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>void</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp" line="64" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp" bodystart="64" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2fill_8hpp_1ab8715f3fb36d3ce5c1505ba621b9c8ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::type hpx::parallel::v1::fill_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;rng, Size count, T value)</argsstring>
        <name>fill_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns the given value value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, for count &gt; 0.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be assigned (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be assigned.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>fill_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>fill_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>fill_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>void</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp" line="121" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/fill.hpp" bodystart="121" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2all__any__none_8hpp_1ab8adfd5bd843e5e3be75695e94ea8a7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::none_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>none_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if unary predicate <emphasis>f</emphasis> returns true for no elements in the range <emphasis>rng</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>none_of</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>none_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>none_of</emphasis> algorithm returns true if the unary predicate <emphasis>f</emphasis> returns true for no elements in the range, false otherwise. It returns true if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/all_any_none.hpp" line="100" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/all_any_none.hpp" bodystart="100" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2all__any__none_8hpp_1a645a8f385208732e17b7fd0edeff88b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::any_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>any_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if unary predicate <emphasis>f</emphasis> returns true for at least one element in the range <emphasis>rng</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>none_of</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>any_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>any_of</emphasis> algorithm returns true if the unary predicate <emphasis>f</emphasis> returns true for at least one element in the range, false otherwise. It returns false if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/all_any_none.hpp" line="183" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/all_any_none.hpp" bodystart="183" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2all__any__none_8hpp_1ab9145664976f55bb15fa51d275d3d3c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::all_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>all_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if unary predicate <emphasis>f</emphasis> returns true for all elements in the range <emphasis>rng</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>none_of</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>all_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>all_of</emphasis> algorithm returns true if the unary predicate <emphasis>f</emphasis> returns true for all elements in the range, false otherwise. It returns true if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/all_any_none.hpp" line="266" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/all_any_none.hpp" bodystart="266" bodyend="272"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2rotate_8hpp_1ab4b35e2f650c01460f25f0db0d9734ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::begin(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::end(typename hpx::traits::range_iterator&lt; Rng &gt;::type) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::begin(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::end(typename hpx::traits::range_iterator&lt;Rng&gt;::type) &gt; &gt;::type hpx::parallel::v1::rotate</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, typename hpx::traits::range_iterator&lt; Rng &gt;::type middle)</argsstring>
        <name>rotate</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>typename hpx::traits::range_iterator&lt; Rng &gt;::type</type>
          <declname>middle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Performs a left rotation on a range of elements. Specifically, <emphasis>rotate</emphasis> swaps the elements in the range [first, last) in such a way that the element new_first becomes the first element of the new range and new_first - 1 becomes the last element.</para><para><simplesect kind="note"><para>Complexity: Linear in the distance between <emphasis>first</emphasis> and <emphasis>last</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>middle</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the element that should appear at the beginning of the rotated range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>rotate</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>rotate</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The type of dereferenced <emphasis>FwdIter</emphasis> must meet the requirements of <emphasis>MoveAssignable</emphasis> and <emphasis>MoveConstructible</emphasis>.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>rotate</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</emphasis> otherwise. The <emphasis>rotate</emphasis> algorithm returns the iterator equal to pair(first + (last - new_first), last). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/rotate.hpp" line="84" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/rotate.hpp" bodystart="84" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2rotate_8hpp_1a00b60fccffa0c06eb6befe8913fab07a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::rotate_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, typename hpx::traits::range_iterator&lt; Rng &gt;::type middle, OutIter dest_first)</argsstring>
        <name>rotate_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>typename hpx::traits::range_iterator&lt; Rng &gt;::type</type>
          <declname>middle</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest_first</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements from the range [first, last), to another range beginning at <emphasis>dest_first</emphasis> in such a way, that the element <emphasis>new_first</emphasis> becomes the first element of the new range and <emphasis>new_first</emphasis> - 1 becomes the last element.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>middle</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the element that should appear at the beginning of the rotated range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the begin of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>rotate_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>rotate_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>rotate_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>rotate_copy</emphasis> algorithm returns the output iterator to the element past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/rotate.hpp" line="150" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/rotate.hpp" bodystart="150" bodyend="155"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2merge_8hpp_1ade9fe7d0b22da8edbf79f0180e956198" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng1</type>
          </param>
          <param>
            <type>typename Rng2</type>
          </param>
          <param>
            <type>typename RandIter3</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(typename hpx::traits::range_iterator&lt; Rng1 &gt;::type), tag::in2(typename hpx::traits::range_iterator&lt; Rng2 &gt;::type), tag::out(RandIter3)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(typename hpx::traits::range_iterator&lt;Rng1&gt;::type), tag::in2(typename hpx::traits::range_iterator&lt;Rng2&gt;::type), tag::out(RandIter3)&gt; &gt;::type hpx::parallel::v1::merge</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, RandIter3 dest, Comp &amp;&amp;comp=Comp(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>merge</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng1 &amp;&amp;</type>
          <declname>rng1</declname>
        </param>
        <param>
          <type>Rng2 &amp;&amp;</type>
          <declname>rng2</declname>
        </param>
        <param>
          <type>RandIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at <emphasis>dest</emphasis>. The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range. The destination range cannot overlap with either of the input ranges.</para><para><simplesect kind="note"><para>Complexity: Performs O(std::distance(first1, last1) + std::distance(first2, last2)) applications of the comparison <emphasis>comp</emphasis> and the each projection.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>merge</emphasis> requires <emphasis>Comp</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the first range. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the second range. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the first range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the second range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>comp(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>RandIter1</emphasis> and <emphasis>RandIter2</emphasis> can be dereferenced and then implicitly converted to both <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the first range as a projection operation before the actual comparison <emphasis>comp</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the second range as a projection operation before the actual comparison <emphasis>comp</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>merge</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</emphasis> otherwise. The <emphasis>merge</emphasis> algorithm returns the tuple of the source iterator <emphasis>last1</emphasis>, the source iterator <emphasis>last2</emphasis>, the destination iterator to the end of the <emphasis>dest</emphasis> range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/merge.hpp" line="142" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/merge.hpp" bodystart="142" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2merge_8hpp_1aafbed5cc1d8d966f97e923fbd8f71100" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename RandIter</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, RandIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, RandIter &gt;::type hpx::parallel::v1::inplace_merge</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, RandIter middle, Comp &amp;&amp;comp=Comp(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>inplace_merge</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>middle</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range.</para><para><simplesect kind="note"><para>Complexity: Performs O(std::distance(first, last)) applications of the comparison <emphasis>comp</emphasis> and the each projection.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>inplace_merge</emphasis> requires <emphasis>Comp</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>middle</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sorted range and the beginning of the second sorted range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>comp(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>RandIter</emphasis> can be dereferenced and then implicitly converted to both <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>inplace_merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>inplace_merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>inplace_merge</emphasis> algorithm returns a <emphasis>hpx::future&lt;RandIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>RandIter</emphasis> otherwise. The <emphasis>inplace_merge</emphasis> algorithm returns the source iterator <emphasis>last</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/merge.hpp" line="243" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/merge.hpp" bodystart="243" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2for__each_8hpp_1a1a9ff31fac164930e57da0f83184aafa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::for_each</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>for_each</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies <emphasis>f</emphasis> to the result of dereferencing every iterator in the given range <emphasis>rng</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Applies <emphasis>f</emphasis> exactly <emphasis>size(rng)</emphasis> times.</para></simplesect>
If <emphasis>f</emphasis> returns a result, the result is ignored.</para><para>If the type of <emphasis>first</emphasis> satisfies the requirements of a mutable iterator, <emphasis>f</emphasis> may apply non-constant functions through the dereferenced iterator.</para><para>Unlike its sequential form, the parallel overload of <emphasis>for_each</emphasis> does not return a copy of its <emphasis>Function</emphasis> parameter, since parallelization may not permit efficient state accumulation.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>for_each</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">&lt;ignored&gt;<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>for_each</emphasis> algorithm returns a <emphasis>hpx::future&lt;InIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>InIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/for_each.hpp" line="107" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/for_each.hpp" bodystart="107" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2search_8hpp_1add319ad54d498c75dc5f5120d87e29bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng1</type>
          </param>
          <param>
            <type>typename Rng2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng1 &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng1&gt;::type &gt;::type hpx::parallel::v1::search</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, Pred &amp;&amp;op=Pred(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>search</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng1 &amp;&amp;</type>
          <declname>rng1</declname>
        </param>
        <param>
          <type>Rng2 &amp;&amp;</type>
          <declname>rng2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most (S*N) comparisons where <emphasis>S</emphasis> = distance(s_first, s_last) and <emphasis>N</emphasis> = distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the examine range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the search range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>adjacent_find</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of <emphasis>Rng1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of <emphasis>Rng2</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be examining. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of <emphasis>rng1</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of <emphasis>rng2</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>search</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>search</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>search</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>search</emphasis> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <emphasis>last</emphasis> is returned. Additionally if the size of the subsequence is empty <emphasis>first</emphasis> is returned. If no subsequence is found, <emphasis>last</emphasis> is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp" line="122" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp" bodystart="122" bodyend="132"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2search_8hpp_1ab45d57e5362f0271e121b82a378e79e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng1</type>
          </param>
          <param>
            <type>typename Rng2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng1 &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng1&gt;::type &gt;::type hpx::parallel::v1::search_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng1 &amp;&amp;rng1, std::size_t count, Rng2 &amp;&amp;rng2, Pred &amp;&amp;op=Pred(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>search_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng1 &amp;&amp;</type>
          <declname>rng1</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>Rng2 &amp;&amp;</type>
          <declname>rng2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most (S*N) comparisons where <emphasis>S</emphasis> = distance(s_first, s_last) and <emphasis>N</emphasis> = distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the examine range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the search range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>adjacent_find</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of <emphasis>Rng1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of <emphasis>Rng2</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be examining. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of elements to apply the algorithm on. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of <emphasis>rng1</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of <emphasis>rng2</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>search</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>search</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>search</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>search</emphasis> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <emphasis>last</emphasis> is returned. Additionally if the size of the subsequence is empty <emphasis>first</emphasis> is returned. If no subsequence is found, <emphasis>last</emphasis> is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp" line="231" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/search.hpp" bodystart="231" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2minmax_8hpp_1abed743f0335718718746bf8206a7bcfb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename F</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::type hpx::parallel::v1::min_element</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f=F(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>min_element</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
          <defval>F()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds the smallest element in the range [first, last) using the given comparison function <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>max</emphasis>(N-1, 0) comparisons, where N = std::distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>min_element</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>min_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>min_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>min_element</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>min_element</emphasis> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/minmax.hpp" line="106" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/minmax.hpp" bodystart="106" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2minmax_8hpp_1a319d10722f06d37f5f0f6abd284133b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename F</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::type hpx::parallel::v1::max_element</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f=F(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>max_element</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
          <defval>F()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds the greatest element in the range [first, last) using the given comparison function <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>max</emphasis>(N-1, 0) comparisons, where N = std::distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>max_element</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the This argument is optional and defaults to std::less. the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>max_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>max_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>max_element</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>max_element</emphasis> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/minmax.hpp" line="193" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/minmax.hpp" bodystart="193" bodyend="199"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2minmax_8hpp_1ad2e21ac895d19b9689a9f7e8dd3b3fb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename F</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::min(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::max(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::min(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::max(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type)&gt; &gt;::type hpx::parallel::v1::minmax_element</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f=F(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>minmax_element</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
          <defval>F()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds the greatest element in the range [first, last) using the given comparison function <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>max</emphasis>(floor(3/2*(N-1)), 0) applications of the predicate, where N = std::distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>minmax_element</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the the left argument is less than the right element. This argument is optional and defaults to std::less. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>minmax_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>minmax_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>minmax_element</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</emphasis> otherwise. The <emphasis>minmax_element</emphasis> algorithm returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/minmax.hpp" line="296" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/minmax.hpp" bodystart="296" bodyend="302"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2transform_8hpp_1a3f7902dd44eace6467f72702ff78c3d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::transform</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>transform</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies the given function <emphasis>f</emphasis> to the given range <emphasis>rng</emphasis> and stores the result in another range, beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Exactly size(rng) applications of <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>OutIter</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>transform</emphasis> algorithm returns a tuple holding an iterator referring to the first element after the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/transform.hpp" line="115" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/transform.hpp" bodystart="115" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2transform_8hpp_1a296e7e5773d39e6c8b4a9a9ce38b00cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename InIter2</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::in2(InIter2), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::in2(InIter2), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::transform</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, InIter2 first2, OutIter dest, F &amp;&amp;f, Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>transform</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>InIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies the given function <emphasis>f</emphasis> to pairs of elements from two ranges: one defined by <emphasis>rng</emphasis> and the other beginning at first2, and stores the result in another range, beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Exactly size(rng) applications of <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>InIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the first sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the second sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types InIter1 and InIter2 can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>OutIter</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>transform</emphasis> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/transform.hpp" line="234" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/transform.hpp" bodystart="234" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2transform_8hpp_1a45593fc520cb2631a4957718bcf0450c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng1</type>
          </param>
          <param>
            <type>typename Rng2</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(typename hpx::traits::range_iterator&lt; Rng1 &gt;::type), tag::in2(typename hpx::traits::range_iterator&lt; Rng2 &gt;::type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(typename hpx::traits::range_iterator&lt;Rng1&gt;::type), tag::in2(typename hpx::traits::range_iterator&lt;Rng2&gt;::type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::transform</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, OutIter dest, F &amp;&amp;f, Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>transform</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng1 &amp;&amp;</type>
          <declname>rng1</declname>
        </param>
        <param>
          <type>Rng2 &amp;&amp;</type>
          <declname>rng2</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies the given function <emphasis>f</emphasis> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Exactly min(last2-first2, last1-first1) applications of <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the first sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the second sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types InIter1 and InIter2 can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>OutIter</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The algorithm will invoke the binary predicate until it reaches the end of the shorter of the two given input sequences</para></simplesect>
<simplesect kind="return"><para>The <emphasis>transform</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>transform</emphasis> algorithm returns a tuple holding an iterator referring to the first element r the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/transform.hpp" line="358" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/transform.hpp" bodystart="358" bodyend="366"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2is__heap_8hpp_1aba109aa6f95bc25e3613e87749385d1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::is_heap</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Comp &amp;&amp;comp=Comp(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>is_heap</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns whether the range is max heap. That is, true if the range is max heap, false otherwise. The function uses the given comparison function object <emphasis>comp</emphasis> (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: Performs at most N applications of the comparison <emphasis>comp</emphasis>, at most 2 * N applications of the projection <emphasis>proj</emphasis>, where N = last - first.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object. The return value of the INVOKE operation applied to an object of type <emphasis>Comp</emphasis>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_heap</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>is_heap</emphasis> algorithm returns whether the range is max heap. That is, true if the range is max heap, false otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/is_heap.hpp" line="93" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/is_heap.hpp" bodystart="93" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2is__heap_8hpp_1adea22d5ed08959243c4d1ee451912da4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::is_heap_until</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Comp &amp;&amp;comp=Comp(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>is_heap_until</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the upper bound of the largest range beginning at <emphasis>first</emphasis> which is a max heap. That is, the last iterator <emphasis>it</emphasis> for which range [first, it) is a max heap. The function uses the given comparison function object <emphasis>comp</emphasis> (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: Performs at most N applications of the comparison <emphasis>comp</emphasis>, at most 2 * N applications of the projection <emphasis>proj</emphasis>, where N = last - first.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object. The return value of the INVOKE operation applied to an object of type <emphasis>Comp</emphasis>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_heap_until</emphasis> algorithm returns a <emphasis>hpx::future&lt;RandIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>RandIter</emphasis> otherwise. The <emphasis>is_heap_until</emphasis> algorithm returns the upper bound of the largest range beginning at first which is a max heap. That is, the last iterator <emphasis>it</emphasis> for which range [first, it) is a max heap. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/is_heap.hpp" line="175" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/is_heap.hpp" bodystart="175" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2remove_8hpp_1ac79b147d283a89405322c1ea937ed28a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::remove</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, T const &amp;value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements that are equal to <emphasis>value</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the operator==() and the projection <emphasis>proj</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to remove (deduced). This value type must meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the value of elements to remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>remove</emphasis> algorithm returns the iterator to the new end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/remove.hpp" line="87" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/remove.hpp" bodystart="87" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2remove_8hpp_1a1aa784b5211d2deeb7e72f53d86f64fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::remove_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Pred &amp;&amp;pred, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements for which predicate <emphasis>pred</emphasis> returns true.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>pred</emphasis> and the projection <emphasis>proj</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>remove_if</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>remove_if</emphasis> algorithm returns the iterator to the new end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/remove.hpp" line="172" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/remove.hpp" bodystart="172" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2sort_8hpp_1a7dce6b68d414854caf498a82c8429f22" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Compare</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::sort</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Compare &amp;&amp;comp=Compare(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>sort</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Compare &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Compare()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sorts the elements in the range <emphasis>rng</emphasis> in ascending order. The order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: O(Nlog(N)), where N = std::distance(begin(rng), end(rng)) comparisons.</para></simplesect>
A sequence is sorted with respect to a comparator <emphasis>comp</emphasis> and a projection <emphasis>proj</emphasis> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each pair of elements as a projection operation before the actual predicate <emphasis>comp</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>sort</emphasis> algorithm returns a <emphasis>hpx::future&lt;Iter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>Iter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/sort.hpp" line="102" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/sort.hpp" bodystart="102" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2find_8hpp_1ac1b769fadbb193028831e2f365a7c73a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Rng2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::find_end</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Rng2 &amp;&amp;rng2, Pred &amp;&amp;op=Pred(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>find_end</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Rng2 &amp;&amp;</type>
          <declname>rng2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the last subsequence of elements <emphasis>rng2</emphasis> found in the range <emphasis>rng</emphasis> using the given predicate <emphasis>f</emphasis> to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most S*(N-S+1) comparisons where <emphasis>S</emphasis> = distance(begin(rng2), end(rng2)) and <emphasis>N</emphasis> = distance(begin(rng), end(rng)).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>replace</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns <emphasis>true</emphasis> if the elements should be treated as equal. The signature should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>iterator_t&lt;Rng&gt;</emphasis> and <emphasis>iterator_t&lt;Rng2&gt;</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>iterator_t&lt;Rng&gt;</emphasis> and dereferenced <emphasis>iterator_t&lt;Rng2&gt;</emphasis> as a projection operation before the function <emphasis>op</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find_end</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find_end</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find_end</emphasis> algorithm returns a <emphasis>hpx::future&lt;iterator_t&lt;Rng&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>iterator_t&lt;Rng&gt;</emphasis> otherwise. The <emphasis>find_end</emphasis> algorithm returns an iterator to the beginning of the last subsequence <emphasis>rng2</emphasis> in range <emphasis>rng</emphasis>. If the length of the subsequence <emphasis>rng2</emphasis> is greater than the length of the range <emphasis>rng</emphasis>, <emphasis>end(rng)</emphasis> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <emphasis>end(rng)</emphasis> is also returned.</para></simplesect>
This overload of <emphasis>find_end</emphasis> is available if the user decides to provide the algorithm their own predicate <emphasis>op</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp" line="122" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp" bodystart="122" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2find_8hpp_1afc111034ef00e843b6dbe8c436c22a69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng1</type>
          </param>
          <param>
            <type>typename Rng2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng1 &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng1&gt;::type &gt;::type hpx::parallel::v1::find_first_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, Pred &amp;&amp;op=Pred(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>find_first_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng1 &amp;&amp;</type>
          <declname>rng1</declname>
        </param>
        <param>
          <type>Rng2 &amp;&amp;</type>
          <declname>rng2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range <emphasis>rng1</emphasis> for any elements in the range <emphasis>rng2</emphasis>. Uses binary predicate <emphasis>p</emphasis> to compare elements</para><para><simplesect kind="note"><para>Complexity: at most (S*N) comparisons where <emphasis>S</emphasis> = distance(begin(rng2), end(rng2)) and <emphasis>N</emphasis> = distance(begin(rng1), end(rng1)).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>replace</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements in <emphasis>rng1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements in <emphasis>rng2</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns <emphasis>true</emphasis> if the elements should be treated as equal. The signature should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>iterator_t&lt;Rng1&gt;</emphasis> and <emphasis>iterator_t&lt;Rng2&gt;</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>iterator_t&lt;Rng1&gt;</emphasis> before the function <emphasis>op</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>iterator_t&lt;Rng2&gt;</emphasis> before the function <emphasis>op</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find_first_of</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find_first_of</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find_end</emphasis> algorithm returns a <emphasis>hpx::future&lt;iterator_t&lt;Rng1&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>iterator_t&lt;Rng1&gt;</emphasis> otherwise. The <emphasis>find_first_of</emphasis> algorithm returns an iterator to the first element in the range <emphasis>rng1</emphasis> that is equal to an element from the range <emphasis>rng2</emphasis>. If the length of the subsequence <emphasis>rng2</emphasis> is greater than the length of the range <emphasis>rng1</emphasis>, <emphasis>end(rng1)</emphasis> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <emphasis>end(rng1)</emphasis> is also returned.</para></simplesect>
This overload of <emphasis>find_first_of</emphasis> is available if the user decides to provide the algorithm their own predicate <emphasis>op</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp" line="236" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/find.hpp" bodystart="236" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2reverse_8hpp_1a55899d840741e9354b54b304ea515310" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::reverse</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng)</argsstring>
        <name>reverse</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reverses the order of the elements in the range [first, last). Behaves as if applying std::iter_swap to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.</para><para><simplesect kind="note"><para>Complexity: Linear in the distance between <emphasis>first</emphasis> and <emphasis>last</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a bidirectional iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>reverse</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>reverse</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reverse</emphasis> algorithm returns a <emphasis>hpx::future&lt;BidirIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>BidirIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/reverse.hpp" line="71" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/reverse.hpp" bodystart="71" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2reverse_8hpp_1a88c284308fbd0d7c233d4feeb35ad35d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::reverse_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest_first)</argsstring>
        <name>reverse_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest_first</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements from the range [first, last) to another range beginning at dest_first in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment *(dest_first + (last - first) - 1 - i) = *(first + i) once for each non-negative i &lt; (last - first) If the source and destination ranges (that is, [first, last) and [dest_first, dest_first+(last-first)) respectively) overlap, the behavior is undefined.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a bidirectional iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutputIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the begin of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>reverse_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>reverse_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reverse_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(BidirIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(BidirIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/reverse.hpp" line="143" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/reverse.hpp" bodystart="143" bodyend="147"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2count_8hpp_1ac0f28cf5bdcce85ec824a3d5019270f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::difference_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::difference_type &gt;::type hpx::parallel::v1::count</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, T const &amp;value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>count</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts the elements that are equal to the given <emphasis>value</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> comparisons.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to search for (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to search for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>count</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para><simplesect kind="note"><para>The comparisons in the parallel <emphasis>count</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>count</emphasis> algorithm returns a <emphasis>hpx::future&lt;difference_type&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>std::iterator_traits&lt;FwdIter&gt;::difference_type</emphasis>. The <emphasis>count</emphasis> algorithm returns the number of elements satisfying the given criteria. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/count.hpp" line="86" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/count.hpp" bodystart="86" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2count_8hpp_1aafeac1e1adb1f843fd06e796504a80b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::difference_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::difference_type &gt;::type hpx::parallel::v1::count_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>count_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts elements for which predicate <emphasis>f</emphasis> returns true.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>count_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The assignments in the parallel <emphasis>count_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread. </para></simplesect>
<simplesect kind="note"><para>The assignments in the parallel <emphasis>count_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>count_if</emphasis> algorithm returns <emphasis>hpx::future&lt;difference_type&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>std::iterator_traits&lt;FwdIter&gt;::difference_type</emphasis>. The <emphasis>count</emphasis> algorithm returns the number of elements satisfying the given criteria. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/count.hpp" line="170" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/count.hpp" bodystart="170" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2partition_8hpp_1a096d7cac5f4c00a41f3d1baa2a71ef00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::partition</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Pred &amp;&amp;pred, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>partition</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reorders the elements in the range <emphasis>rng</emphasis> in such a way that all elements for which the predicate <emphasis>pred</emphasis> returns true precede the elements for which the predicate <emphasis>pred</emphasis> returns false. Relative order of the elements is not preserved.</para><para><simplesect kind="note"><para>Complexity: Performs at most 2 * N swaps, exactly N applications of the predicate and projection, where N = std::distance(begin(rng), end(rng)).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>partition</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <emphasis>rng</emphasis>. This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>partition</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>partition</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>partition</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>partition</emphasis> algorithm returns the iterator to the first element of the second group. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/partition.hpp" line="102" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/partition.hpp" bodystart="102" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2partition_8hpp_1aeda6e8aca718703d5e97ad7e0eabc227" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::out1(FwdIter2), tag::out2(FwdIter3)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::out1(FwdIter2), tag::out2(FwdIter3)&gt; &gt;::type hpx::parallel::v1::partition_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, FwdIter2 dest_true, FwdIter3 dest_false, Pred &amp;&amp;pred, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>partition_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest_true</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest_false</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range <emphasis>rng</emphasis>, to two different ranges depending on the value returned by the predicate <emphasis>pred</emphasis>. The elements, that satisfy the predicate <emphasis>pred</emphasis>, are copied to the range beginning at <emphasis>dest_true</emphasis>. The rest of the elements are copied to the range beginning at <emphasis>dest_false</emphasis>. The order of the elements is preserved.</para><para><simplesect kind="note"><para>Complexity: Performs not more than N assignments, exactly N applications of the predicate <emphasis>pred</emphasis>, where N = std::distance(begin(rng), end(rng)).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range for the elements that satisfy the predicate <emphasis>pred</emphasis> (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range for the elements that don&apos;t satisfy the predicate <emphasis>pred</emphasis> (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>partition_copy</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_true</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range for the elements that satisfy the predicate <emphasis>pred</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_false</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range for the elements that don&apos;t satisfy the predicate <emphasis>pred</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <emphasis>rng</emphasis>. This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>partition_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>partition_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>partition_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</emphasis> otherwise. The <emphasis>partition_copy</emphasis> algorithm returns the tuple of the source iterator <emphasis>last</emphasis>, the destination iterator to the end of the <emphasis>dest_true</emphasis> range, and the destination iterator to the end of the <emphasis>dest_false</emphasis> range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/partition.hpp" line="210" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/partition.hpp" bodystart="210" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2copy_8hpp_1ae711203bbd4bdcb06d3bfbb43aa4b05c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest)</argsstring>
        <name>copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range <emphasis>rng</emphasis> to another range beginning at <emphasis>dest</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Performs exactly std::distance(begin(rng), end(rng)) assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</emphasis>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</emphasis>, tag::out(FwdIter2)&gt; otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/copy.hpp" line="83" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/copy.hpp" bodystart="83" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2copy_8hpp_1a003196f2c0a0f8406b8e8b641288d34a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::copy_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>copy_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range <emphasis>rng</emphasis> to another range beginning at <emphasis>dest</emphasis>. Copies only the elements for which the predicate <emphasis>f</emphasis> returns true. The order of the elements that are not removed is preserved.</para><para><simplesect kind="note"><para>Complexity: Performs not more than std::distance(begin(rng), end(rng)) assignments, exactly std::distance(begin(rng), end(rng)) applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</emphasis>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</emphasis>, tag::out(FwdIter2)&gt; otherwise. The <emphasis>copy_if</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/copy.hpp" line="178" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/copy.hpp" bodystart="178" bodyend="184"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2unique_8hpp_1a90480589220990ce8e7c13abab51b619" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt; Rng &gt;::type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_iterator&lt;Rng&gt;::type &gt;::type hpx::parallel::v1::unique</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, Pred &amp;&amp;pred=Pred(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>unique</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Eliminates all but the first element from every consecutive group of equivalent elements from the range <emphasis>rng</emphasis> and returns a past-the-end iterator for the new logical end of the range.</para><para><simplesect kind="note"><para>Complexity: Performs not more than N assignments, exactly N - 1 applications of the predicate <emphasis>pred</emphasis> and no more than twice as many applications of the projection <emphasis>proj</emphasis>, where N = std::distance(begin(rng), end(rng)).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>unique</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a,<sp/>const<sp/>Type<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>unique</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>unique</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>unique</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>unique</emphasis> algorithm returns the iterator to the new end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/unique.hpp" line="108" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/unique.hpp" bodystart="108" bodyend="115"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2unique_8hpp_1a002f249dd112bdd7074b671d5c3f69a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt; Rng &gt;::type), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_iterator&lt;Rng&gt;::type), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::unique_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, FwdIter2 dest, Pred &amp;&amp;pred=Pred(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>unique_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements from the range <emphasis>rng</emphasis>, to another range beginning at <emphasis>dest</emphasis> in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</para><para><simplesect kind="note"><para>Complexity: Performs not more than N assignments, exactly N - 1 applications of the predicate <emphasis>pred</emphasis>, where N = std::distance(begin(rng), end(rng)).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>unique_copy</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <emphasis>rng</emphasis>. This is an binary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a,<sp/>const<sp/>Type<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>unique_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>unique_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>unique_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>unique_copy</emphasis> algorithm returns the pair of the source iterator to <emphasis>last</emphasis>, and the destination iterator to the end of the <emphasis>dest</emphasis> range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/unique.hpp" line="209" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/unique.hpp" bodystart="209" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2replace_8hpp_1aefef1778072b50648bc152b6c9706046" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::type hpx::parallel::v1::replace</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, T1 const &amp;old_value, T2 const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>T1 const &amp;</type>
          <declname>old_value</declname>
        </param>
        <param>
          <type>T2 const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replaces all elements satisfying specific criteria with <emphasis>new_value</emphasis> in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
Effects: Substitutes elements referred by the iterator it in the range [first,last) with new_value, when the following corresponding conditions hold: INVOKE(proj, *i) == old_value</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the old value to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the old value of the elements to replace. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>void</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" line="89" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" bodystart="89" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2replace_8hpp_1ab39c066bb39cf49738f1cf8a84a586a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type &gt;::type hpx::parallel::v1::replace_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, F &amp;&amp;f, T const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replaces all elements satisfying specific criteria (for which predicate <emphasis>f</emphasis> returns true) with <emphasis>new_value</emphasis> in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(f, INVOKE(proj, *it)) != false</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the elements which need to replaced. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>void</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" line="177" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" bodystart="177" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2replace_8hpp_1a389f87159d80eef0638c8230faeefbf2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::replace_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest, T1 const &amp;old_value, T2 const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T1 const &amp;</type>
          <declname>old_value</declname>
        </param>
        <param>
          <type>T2 const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the all elements from the range [first, last) to another range beginning at <emphasis>dest</emphasis> replacing all elements satisfying a specific criteria with <emphasis>new_value</emphasis>.</para><para>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(proj, *(first + (i - result))) == old_value</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the old value to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the old value of the elements to replace. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" line="266" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" bodystart="266" bodyend="272"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2replace_8hpp_1a08cb18b548967fc8c26fa4da201f6501" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::replace_copy_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest, F &amp;&amp;f, T const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace_copy_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the all elements from the range [first, last) to another range beginning at <emphasis>dest</emphasis> replacing all elements satisfying a specific criteria with <emphasis>new_value</emphasis>.</para><para>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(f, INVOKE(proj, *(first + (i - result)))) != false</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the elements which need to replaced. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_copy_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>replace_copy_if</emphasis> algorithm returns the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" line="371" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/replace.hpp" bodystart="371" bodyend="377"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2remove__copy_8hpp_1a502c6c257508e5a53719171a10a9da8d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::remove_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest, T const &amp;val, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>val</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to another range beginning at <emphasis>dest</emphasis>. Copies only the elements for which the comparison operator returns false when compare to val. The order of the elements that are not removed is preserved.</para><para>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(proj, *it) == value</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type that the result of dereferencing InIter is compared to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be removed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/remove_copy.hpp" line="111" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/remove_copy.hpp" bodystart="111" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="container__algorithms_2remove__copy_8hpp_1abd0452821fded9de150d1bfee84a6388" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename Rng</type>
          </param>
          <param>
            <type>typename OutIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt; Rng &gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(typename hpx::traits::range_traits&lt;Rng&gt;::iterator_type), tag::out(OutIter) &gt; &gt;::type hpx::parallel::v1::remove_copy_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, Rng &amp;&amp;rng, OutIter dest, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove_copy_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>Rng &amp;&amp;</type>
          <declname>rng</declname>
        </param>
        <param>
          <type>OutIter</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to another range beginning at <emphasis>dest</emphasis>. Copies only the elements for which the predicate <emphasis>f</emphasis> returns false. The order of the elements that are not removed is preserved.</para><para>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(pred, INVOKE(proj, *it)) != false.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Rng</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>OutIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rng</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the elements to be removed. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove_copy_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/container_algorithms/remove_copy.hpp" line="216" column="1" bodyfile="libs/algorithms/include/hpx/parallel/container_algorithms/remove_copy.hpp" bodystart="216" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="is__sorted_8hpp_1a85efa0a779518b75859d9c55fd211cb0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type &gt;::type hpx::parallel::v1::is_sorted</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;pred=Pred())</argsstring>
        <name>is_sorted</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determines if the range [first, last) is sorted. Uses pred to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most (N+S-1) comparisons where <emphasis>N</emphasis> = distance(first, last). <emphasis>S</emphasis> = number of partitions</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>is_sorted</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of that the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a,<sp/>const<sp/>Type<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that objects of types <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>is_sorted</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> executes in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>is_sorted</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_sorted</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>is_sorted</emphasis> algorithm returns a bool if each element in the sequence [first, last) satisfies the predicate passed. If the range [first, last) contains less than two elements, the function always returns true. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp" line="174" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp" bodystart="174" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="is__sorted_8hpp_1a2de35f1dad5cc7422fad516a7624daa5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type &gt;::type hpx::parallel::v1::is_sorted_until</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;pred=Pred())</argsstring>
        <name>is_sorted_until</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the first element in the range [first, last) that is not sorted. Uses a predicate to compare elements or the less than operator.</para><para><simplesect kind="note"><para>Complexity: at most (N+S-1) comparisons where <emphasis>N</emphasis> = distance(first, last). <emphasis>S</emphasis> = number of partitions</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>is_sorted_until</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of that the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a,<sp/>const<sp/>Type<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that objects of types <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>is_sorted_until</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> executes in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>is_sorted_until</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_sorted_until</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>is_sorted_until</emphasis> algorithm returns the first unsorted element. If the sequence has less than two elements or the sequence is sorted, last is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp" line="330" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/is_sorted.hpp" bodystart="330" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="is__partitioned_8hpp_1ad7462a990ff3755c73bf5cfa130cd70a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type &gt;::type hpx::parallel::v1::is_partitioned</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;pred)</argsstring>
        <name>is_partitioned</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determines if the range [first, last) is partitioned.</para><para><simplesect kind="note"><para>Complexity: at most (N) predicate evaluations where <emphasis>N</emphasis> = distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of that the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a,<sp/>const<sp/>Type<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that objects of types <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type.</para></parameterdescription>
</parameteritem>
</parameterlist>
The predicate operations in the parallel <emphasis>is_partitioned</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> executes in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>is_partitioned</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_partitioned</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>is_partitioned</emphasis> algorithm returns true if each element in the sequence for which pred returns true precedes those for which pred returns false. Otherwise is_partitioned returns false. If the range [first, last) contains less than two elements, the function is always true. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/is_partitioned.hpp" line="185" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/is_partitioned.hpp" bodystart="185" bodyend="196"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2generate_8hpp_1a8b4e673fc690318448e989c780055d17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::generate</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f)</argsstring>
        <name>generate</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assign each element in range [first, last) a value generated by the given function object f</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>distance(first, last)</emphasis> invocations of <emphasis>f</emphasis> and assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>generator function that will be called. signature of function should be equivalent to the following: <programlisting><codeline><highlight class="normal">Ret<sp/>fun();</highlight></codeline>
</programlisting> <linebreak/>
 The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>generate</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>generate</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/generate.hpp" line="150" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/generate.hpp" bodystart="150" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2generate_8hpp_1a76accd6d0c29469d74b51c9ebb3d4586" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::generate_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count, F &amp;&amp;f)</argsstring>
        <name>generate_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns each element in range [first, first+count) a value generated by the given function object g.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>count</emphasis> invocations of <emphasis>f</emphasis> and assignments, for count &gt; 0.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements in the sequence the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the generator function object that will be called. The signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">Ret<sp/>fun();</highlight></codeline>
</programlisting> <linebreak/>
 The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>OutputIt</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>generate_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>generate_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/generate.hpp" line="261" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/generate.hpp" bodystart="261" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2move_8hpp_1a8becd6c721d0fa25a574df7bc22088c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::move</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest)</argsstring>
        <name>move</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Moves the elements in the range [first, last), to another range beginning at <emphasis>dest</emphasis>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> move assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the move assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The move assignments in the parallel <emphasis>move</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The move assignments in the parallel <emphasis>move</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>move</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>move</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element moved. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/move.hpp" line="170" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/move.hpp" bodystart="170" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__fill_8hpp_1a701ffa8fa1e317359d0d67afd73b865d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy&gt;::type &gt;::type hpx::parallel::v1::uninitialized_fill</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, T const &amp;value)</argsstring>
        <name>uninitialized_fill</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the given <emphasis>value</emphasis> to an uninitialized memory area, defined by the range [first, last). If an exception is thrown during the initialization, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Linear in the distance between <emphasis>first</emphasis> and <emphasis>last</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be assigned (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be assigned.</para></parameterdescription>
</parameteritem>
</parameterlist>
The initializations in the parallel <emphasis>uninitialized_fill</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The initializations in the parallel <emphasis>uninitialized_fill</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_fill</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns nothing otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp" line="201" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp" bodystart="201" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__fill_8hpp_1a6fd7b303fbd92ff86b28eeed710ab5a7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy&gt;::type &gt;::type hpx::parallel::v1::uninitialized_fill_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count, T const &amp;value)</argsstring>
        <name>uninitialized_fill_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the given <emphasis>value</emphasis> value to the first count elements in an uninitialized memory area beginning at first. If an exception is thrown during the initialization, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, if count &gt; 0, no assignments otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be assigned (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be assigned.</para></parameterdescription>
</parameteritem>
</parameterlist>
The initializations in the parallel <emphasis>uninitialized_fill_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The initializations in the parallel <emphasis>uninitialized_fill_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_fill_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns nothing otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp" line="321" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_fill.hpp" bodystart="321" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2fill_8hpp_1ab171416328f41cfba30983f0ed87d857" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy&gt;::type hpx::parallel::v1::fill</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, T value)</argsstring>
        <name>fill</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns the given value to the elements in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be assigned (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be assigned.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>fill</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>fill</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>fill</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>void</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/fill.hpp" line="159" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/fill.hpp" bodystart="159" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2fill_8hpp_1a7af4288c99d46acbc017b1f8e7ef7ac8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::fill_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count, T value)</argsstring>
        <name>fill_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns the given value value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, for count &gt; 0.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be assigned (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to be assigned.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>fill_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>fill_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>fill_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>void</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/fill.hpp" line="262" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/fill.hpp" bodystart="262" bodyend="280"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__move_8hpp_1a58724c8d012c1ffe714681f0ed0661cd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type hpx::parallel::v1::uninitialized_move</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest)</argsstring>
        <name>uninitialized_move</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Moves the elements in the range, defined by [first, last), to an uninitialized memory area beginning at <emphasis>dest</emphasis>. If an exception is thrown during the initialization, some objects in [first, last) are left in a valid but unspecified state.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> move operations.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_move</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_move</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_move</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>uninitialized_move</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element moved. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp" line="233" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp" bodystart="233" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__move_8hpp_1a3fcd3f40742c12956fb8e9650a121a92" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::uninitialized_move_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, Size count, FwdIter2 dest)</argsstring>
        <name>uninitialized_move_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Moves the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest. If an exception is thrown during the initialization, some objects in [first, first + count) are left in a valid but unspecified state.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> movements, if count &gt; 0, no move operations otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_move_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_move_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_move_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;std::pair&lt;FwdIter1, FwdIter2&gt;&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>std::pair&lt;FwdIter1, FwdIter2&gt;</emphasis> otherwise. The <emphasis>uninitialized_move_n</emphasis> algorithm returns the pair of the input iterator to the element past in the source range and an output iterator to the element in the destination range, one past the last element moved. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp" line="372" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_move.hpp" bodystart="372" bodyend="397"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2all__any__none_8hpp_1a5f34b49fe744e1ea82df76e1c514aa49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::none_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>none_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if unary predicate <emphasis>f</emphasis> returns true for no elements in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>none_of</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>none_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>none_of</emphasis> algorithm returns true if the unary predicate <emphasis>f</emphasis> returns true for no elements in the range, false otherwise. It returns true if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp" line="206" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp" bodystart="206" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2all__any__none_8hpp_1afab0800132ab9eedfc6cf4fd89ee1913" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::any_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>any_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if unary predicate <emphasis>f</emphasis> returns true for at least one element in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>any_of</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>any_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>any_of</emphasis> algorithm returns true if the unary predicate <emphasis>f</emphasis> returns true for at least one element in the range, false otherwise. It returns false if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp" line="389" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp" bodystart="389" bodyend="397"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2all__any__none_8hpp_1a879e3cf8d3b4a2d70efa0dce73acb5ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::all_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>all_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if unary predicate <emphasis>f</emphasis> returns true for all elements in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>all_of</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>all_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>all_of</emphasis> algorithm returns true if the unary predicate <emphasis>f</emphasis> returns true for all elements in the range, false otherwise. It returns true if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp" line="571" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/all_any_none.hpp" bodystart="571" bodyend="579"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2rotate_8hpp_1aa2dd57730fb01287bae897aa8a2d4591" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::begin(FwdIter), tag::end(FwdIter)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt; &gt;::type hpx::parallel::v1::rotate</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter new_first, FwdIter last)</argsstring>
        <name>rotate</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>new_first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Performs a left rotation on a range of elements. Specifically, <emphasis>rotate</emphasis> swaps the elements in the range [first, last) in such a way that the element new_first becomes the first element of the new range and new_first - 1 becomes the last element.</para><para><simplesect kind="note"><para>Complexity: Linear in the distance between <emphasis>first</emphasis> and <emphasis>last</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the element that should appear at the beginning of the rotated range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>rotate</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>rotate</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The type of dereferenced <emphasis>FwdIter</emphasis> must meet the requirements of <emphasis>MoveAssignable</emphasis> and <emphasis>MoveConstructible</emphasis>.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>rotate</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</emphasis> otherwise. The <emphasis>rotate</emphasis> algorithm returns the iterator equal to pair(first + (last - new_first), last). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp" line="186" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp" bodystart="186" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2rotate_8hpp_1ac4b99b981ee97f50731f009ee48cf1a3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::rotate_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 new_first, FwdIter1 last, FwdIter2 dest_first)</argsstring>
        <name>rotate_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>new_first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest_first</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements from the range [first, last), to another range beginning at <emphasis>dest_first</emphasis> in such a way, that the element <emphasis>new_first</emphasis> becomes the first element of the new range and <emphasis>new_first</emphasis> - 1 becomes the last element.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the element that should appear at the beginning of the rotated range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the begin of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>rotate_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>rotate_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>rotate_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>rotate_copy</emphasis> algorithm returns the output iterator to the element past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp" line="338" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/rotate.hpp" bodystart="338" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2merge_8hpp_1adb389c5b2102405a9f26c0633816e96e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename RandIter1</type>
          </param>
          <param>
            <type>typename RandIter2</type>
          </param>
          <param>
            <type>typename RandIter3</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt; &gt;::type hpx::parallel::v1::merge</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, RandIter1 first1, RandIter1 last1, RandIter2 first2, RandIter2 last2, RandIter3 dest, Comp &amp;&amp;comp=Comp(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>merge</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>RandIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>RandIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>RandIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>RandIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>RandIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at <emphasis>dest</emphasis>. The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range. The destination range cannot overlap with either of the input ranges.</para><para><simplesect kind="note"><para>Complexity: Performs O(std::distance(first1, last1) + std::distance(first2, last2)) applications of the comparison <emphasis>comp</emphasis> and the each projection.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sorted range. This iterator type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the second sorted range. This iterator type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>merge</emphasis> requires <emphasis>Comp</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the first range. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the second range. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the second range of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>comp(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>RandIter1</emphasis> and <emphasis>RandIter2</emphasis> can be dereferenced and then implicitly converted to both <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the first range as a projection operation before the actual comparison <emphasis>comp</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the second range as a projection operation before the actual comparison <emphasis>comp</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>merge</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</emphasis> otherwise. The <emphasis>merge</emphasis> algorithm returns the tuple of the source iterator <emphasis>last1</emphasis>, the source iterator <emphasis>last2</emphasis>, the destination iterator to the end of the <emphasis>dest</emphasis> range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/merge.hpp" line="476" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/merge.hpp" bodystart="476" bodyend="502"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2merge_8hpp_1acb1ee3de7dba68b96b6dc668cd380e7a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename RandIter</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, RandIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, RandIter &gt;::type hpx::parallel::v1::inplace_merge</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, RandIter first, RandIter middle, RandIter last, Comp &amp;&amp;comp=Comp(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>inplace_merge</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>middle</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range.</para><para><simplesect kind="note"><para>Complexity: Performs O(std::distance(first, last)) applications of the comparison <emphasis>comp</emphasis> and the each projection.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>inplace_merge</emphasis> requires <emphasis>Comp</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first sorted range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>middle</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sorted range and the beginning of the second sorted range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the second sorted range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>comp(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>RandIter</emphasis> can be dereferenced and then implicitly converted to both <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>inplace_merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>inplace_merge</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>inplace_merge</emphasis> algorithm returns a <emphasis>hpx::future&lt;RandIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>RandIter</emphasis> otherwise. The <emphasis>inplace_merge</emphasis> algorithm returns the source iterator <emphasis>last</emphasis> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/merge.hpp" line="818" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/merge.hpp" bodystart="818" bodyend="833"/>
      </memberdef>
      <memberdef kind="function" id="adjacent__find_8hpp_1a5adc6ae701415ba01961fa29836e00fa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type &gt;::type hpx::parallel::v1::adjacent_find</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;op=Pred())</argsstring>
        <name>adjacent_find</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range [first, last) for two consecutive identical elements. This version uses the given binary predicate op</para><para><simplesect kind="note"><para>Complexity: Exactly the smaller of (result - first) + 1 and (last - first) - 1 application of the predicate where <emphasis>result</emphasis> is the value returned</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>adjacent_find</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns <emphasis>true</emphasis> if the elements should be treated as equal. The signature should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> .</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>adjacent_find</emphasis> invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>adjacent_find</emphasis> invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>adjacent_find</emphasis> algorithm returns a <emphasis>hpx::future&lt;InIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>InIter</emphasis> otherwise. The <emphasis>adjacent_find</emphasis> algorithm returns an iterator to the first of the identical elements. If no such elements are found, <emphasis>last</emphasis> is returned.</para></simplesect>
This overload of <emphasis>adjacent_find</emphasis> is available if the user decides to provide their algorithm their own binary predicate <emphasis>op</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/adjacent_find.hpp" line="197" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/adjacent_find.hpp" bodystart="197" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="mismatch_8hpp_1ad2210ac36941837306cdf8c12114a31a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, std::pair&lt; FwdIter1, FwdIter2 &gt; &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, std::pair&lt;FwdIter1, FwdIter2&gt; &gt;::type &gt;::type hpx::parallel::v1::mismatch</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, Pred &amp;&amp;op=Pred())</argsstring>
        <name>mismatch</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns true if the range [first1, last1) is mismatch to the range [first2, last2), and false otherwise.</para><para><simplesect kind="note"><para>Complexity: At most min(last1 - first1, last2 - first2) applications of the predicate <emphasis>f</emphasis>. If <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> meet the requirements of <emphasis>RandomAccessIterator</emphasis> and (last1 - first1) != (last2 - first2) then no applications of the predicate <emphasis>f</emphasis> are made.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>mismatch</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as mismatch. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>mismatch</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>mismatch</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The two ranges are considered mismatch if, for every iterator i in the range [first1,last1), *i mismatchs *(first2 + (i - first1)). This overload of mismatch uses operator== to determine if two elements are mismatch.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>mismatch</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>mismatch</emphasis> algorithm returns true if the elements in the two ranges are mismatch, otherwise it returns false. If the length of the range [first1, last1) does not mismatch the length of the range [first2, last2), it returns false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp" line="227" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp" bodystart="227" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="mismatch_8hpp_1a6476df5b4e5ac7c2cef766f4e84b52a5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, std::pair&lt; FwdIter1, FwdIter2 &gt; &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, std::pair&lt;FwdIter1, FwdIter2&gt; &gt;::type &gt;::type hpx::parallel::v1::mismatch</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, Pred &amp;&amp;op=Pred())</argsstring>
        <name>mismatch</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns std::pair with iterators to the first two non-equivalent elements.</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>last1</emphasis> - <emphasis>first1</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>mismatch</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as mismatch. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>mismatch</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>mismatch</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>mismatch</emphasis> algorithm returns a <emphasis>hpx::future&lt;std::pair&lt;FwdIter1, FwdIter2&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>std::pair&lt;FwdIter1, FwdIter2&gt;</emphasis> otherwise. The <emphasis>mismatch</emphasis> algorithm returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2, last2). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp" line="396" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/mismatch.hpp" bodystart="396" bodyend="412"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2for__each_8hpp_1ae99cf785be3f48daf11e9ff21e2c2ebb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::for_each_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>for_each_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies <emphasis>f</emphasis> to the result of dereferencing every iterator in the range [first, first + count), starting from first and proceeding to first + count - 1.</para><para><simplesect kind="note"><para>Complexity: Applies <emphasis>f</emphasis> exactly <emphasis>count</emphasis> times.</para></simplesect>
If <emphasis>f</emphasis> returns a result, the result is ignored.</para><para>If the type of <emphasis>first</emphasis> satisfies the requirements of a mutable iterator, <emphasis>f</emphasis> may apply non-constant functions through the dereferenced iterator.</para><para>Unlike its sequential form, the parallel overload of <emphasis>for_each</emphasis> does not return a copy of its <emphasis>Function</emphasis> parameter, since parallelization may not permit efficient state accumulation.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>for_each</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">&lt;ignored&gt;<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>for_each_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. It returns <emphasis>first</emphasis> + <emphasis>count</emphasis> for non-negative values of <emphasis>count</emphasis> and <emphasis>first</emphasis> for negative values. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp" line="344" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp" bodystart="344" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2for__each_8hpp_1a4eeac314eec9001c03e68882d85e9123" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::for_each</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>for_each</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies <emphasis>f</emphasis> to the result of dereferencing every iterator in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: Applies <emphasis>f</emphasis> exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> times.</para></simplesect>
If <emphasis>f</emphasis> returns a result, the result is ignored.</para><para>If the type of <emphasis>first</emphasis> satisfies the requirements of a mutable iterator, <emphasis>f</emphasis> may apply non-constant functions through the dereferenced iterator.</para><para>Unlike its sequential form, the parallel overload of <emphasis>for_each</emphasis> does not return a copy of its <emphasis>Function</emphasis> parameter, since parallelization may not permit efficient state accumulation.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>for_each</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">&lt;ignored&gt;<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>for_each</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp" line="540" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/for_each.hpp" bodystart="540" bodyend="552"/>
      </memberdef>
      <memberdef kind="function" id="set__union_8hpp_1ab6f109dcd077c01e1e7f9f34e8916f51" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter3 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type &gt;::type hpx::parallel::v1::set_union</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, FwdIter3 dest, Pred &amp;&amp;op=Pred())</argsstring>
        <name>set_union</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a sorted range beginning at dest consisting of all elements present in one or both sorted ranges [first1, last1) and [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <emphasis>N1</emphasis> is the length of the first sequence and <emphasis>N2</emphasis> is the length of the second sequence.</para></simplesect>
If some element is found <emphasis>m</emphasis> times in [first1, last1) and <emphasis>n</emphasis> times in [first2, last2), then all <emphasis>m</emphasis> elements will be copied from [first1, last1) to dest, preserving order, and then exactly std::max(n-m, 0) elements will be copied from [first2, last2) to dest, also preserving order.</para><para>The resulting range cannot overlap with either of the input ranges.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>set_union</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (<emphasis>sequenced_policy</emphasis>) or in a single new thread spawned from the current thread (for <emphasis>sequenced_task_policy</emphasis>).</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>set_union</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter3&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter3</emphasis> otherwise. The <emphasis>set_union</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/set_union.hpp" line="208" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/set_union.hpp" bodystart="208" bodyend="230"/>
      </memberdef>
      <memberdef kind="function" id="transform__exclusive__scan_8hpp_1a5b927b96e3f7a187d5762f2e88217319" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename Conv</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type hpx::parallel::v1::transform_exclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, T init, Op &amp;&amp;op, Conv &amp;&amp;conv)</argsstring>
        <name>transform_exclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>Conv &amp;&amp;</type>
          <declname>conv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(binary_op, init, conv(*first), ..., conv(*(first + (i - result) - 1))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicates <emphasis>op</emphasis> and <emphasis>conv</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Conv</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the unary function object used for the conversion operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">R<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to Type. The type <emphasis>R</emphasis> must be such that an object of this type can be implicitly converted to <emphasis>T</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Ret</emphasis> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>transform_exclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>transform_exclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>transform_exclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, ..., aN) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></simplesect>
Neither <emphasis>conv</emphasis> nor <emphasis>op</emphasis> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).</para><para>The behavior of transform_exclusive_scan may be non-deterministic for a non-associative predicate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform_exclusive_scan.hpp" line="317" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform_exclusive_scan.hpp" bodystart="317" bodyend="324"/>
      </memberdef>
      <memberdef kind="function" id="reduce__by__key_8hpp_1ac7bcf699ef55259496e9060f0e784c17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename RanIter</type>
          </param>
          <param>
            <type>typename RanIter2</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Compare</type>
            <defval>std::equal_to&lt;typename std::iterator_traits&lt;RanIter&gt;::value_type&gt;</defval>
          </param>
          <param>
            <type>typename Func</type>
            <defval>std::plus&lt;            typename std::iterator_traits&lt;RanIter2&gt;::value_type&gt;</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, std::pair&lt; FwdIter1, FwdIter2 &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, std::pair&lt;FwdIter1, FwdIter2&gt; &gt;::type hpx::parallel::v1::reduce_by_key</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, RanIter key_first, RanIter key_last, RanIter2 values_first, FwdIter1 keys_output, FwdIter2 values_output, Compare &amp;&amp;comp=Compare(), Func &amp;&amp;func=Func())</argsstring>
        <name>reduce_by_key</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>RanIter</type>
          <declname>key_first</declname>
        </param>
        <param>
          <type>RanIter</type>
          <declname>key_last</declname>
        </param>
        <param>
          <type>RanIter2</type>
          <declname>values_first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>keys_output</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>values_output</declname>
        </param>
        <param>
          <type>Compare &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Compare()</defval>
        </param>
        <param>
          <type>Func &amp;&amp;</type>
          <declname>func</declname>
          <defval>Func()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reduce by Key performs an inclusive scan reduction operation on elements supplied in key/value pairs. The algorithm produces a single output value for each set of equal consecutive keys in [key_first, key_last). the value being the GENERALIZED_NONCOMMUTATIVE_SUM(op, init, *first, ..., *(first + (i - result))). for the run of consecutive matching keys. The number of keys supplied must match the number of values.</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RanIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the key iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RanIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination key range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination value range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Compare</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the optional function/function object to use to compare keys (deduced). Assumed to be std::equal_to otherwise. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Func</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of key elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key_last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of key elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>values_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of value elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>keys_output</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the start output location for the keys produced by the algorithm. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>values_output</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the start output location for the values produced by the algorithm. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The types <emphasis>Type1</emphasis> <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reduce_by_key</emphasis> algorithm returns a <emphasis>hpx::future&lt;pair&lt;Iter1,Iter2&gt;&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>pair&lt;Iter1,Iter2&gt;</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/reduce_by_key.hpp" line="586" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/reduce_by_key.hpp" bodystart="586" bodyend="618"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2search_8hpp_1a0422631fee0a3f2510ebb2cfbd4698e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::search</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, FwdIter2 s_first, FwdIter2 s_last, Pred &amp;&amp;op=Pred(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>search</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>s_first</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>s_last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most (S*N) comparisons where <emphasis>S</emphasis> = distance(s_first, s_last) and <emphasis>N</emphasis> = distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>adjacent_find</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of type dereferenced <emphasis>FwdIter</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of type dereferenced <emphasis>FwdIter2</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s_last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter1</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter2</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>search</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>search</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>search</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>search</emphasis> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <emphasis>last</emphasis> is returned. Additionally if the size of the subsequence is empty <emphasis>first</emphasis> is returned. If no subsequence is found, <emphasis>last</emphasis> is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/search.hpp" line="245" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/search.hpp" bodystart="245" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2search_8hpp_1ad56291e6bf23d7d9ecf498368c55017c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::search_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, std::size_t count, FwdIter2 s_first, FwdIter2 s_last, Pred &amp;&amp;op=Pred(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>search_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::size_t</type>
          <declname>count</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>s_first</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>s_last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most (S*N) comparisons where <emphasis>S</emphasis> = distance(s_first, s_last) and <emphasis>N</emphasis> = count.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>adjacent_find</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the range of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s_last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter1</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter2</emphasis> as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>search_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>search_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>search_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>task_execution_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>search_n</emphasis> algorithm returns an iterator to the beginning of the last subsequence [s_first, s_last) in range [first, first+count). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, first+count), <emphasis>first</emphasis> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <emphasis>first</emphasis> is also returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/search.hpp" line="467" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/search.hpp" bodystart="467" bodyend="484"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2minmax_8hpp_1a24dba382bbce6a2fb11fadf711656d95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename F</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::min_element</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f=F(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>min_element</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
          <defval>F()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds the smallest element in the range [first, last) using the given comparison function <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>max</emphasis>(N-1, 0) comparisons, where N = std::distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>min_element</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>min_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>min_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>min_element</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>min_element</emphasis> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp" line="257" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp" bodystart="257" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2minmax_8hpp_1a624ca7fa873d5c8200717ab1f2c15e35" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename F</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::max_element</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f=F(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>max_element</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
          <defval>F()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds the greatest element in the range [first, last) using the given comparison function <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>max</emphasis>(N-1, 0) comparisons, where N = std::distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>max_element</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the This argument is optional and defaults to std::less. the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>max_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>max_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>max_element</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>max_element</emphasis> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp" line="492" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp" bodystart="492" bodyend="504"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2minmax_8hpp_1ae19ab1d1771be7fd161a092e23c879f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename F</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::min(FwdIter), tag::max(FwdIter)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt; &gt;::type hpx::parallel::v1::minmax_element</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f=F(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>minmax_element</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
          <defval>F()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds the greatest element in the range [first, last) using the given comparison function <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>max</emphasis>(floor(3/2*(N-1)), 0) applications of the predicate, where N = std::distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>minmax_element</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the the left argument is less than the right element. This argument is optional and defaults to std::less. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>minmax_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparisons in the parallel <emphasis>minmax_element</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>minmax_element</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</emphasis> otherwise. The <emphasis>minmax_element</emphasis> algorithm returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp" line="766" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/minmax.hpp" bodystart="766" bodyend="779"/>
      </memberdef>
      <memberdef kind="function" id="equal_8hpp_1a0c7fdfade58cb9d4dda65892a877aa58" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type &gt;::type hpx::parallel::v1::equal</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, Pred &amp;&amp;op=Pred())</argsstring>
        <name>equal</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.</para><para><simplesect kind="note"><para>Complexity: At most min(last1 - first1, last2 - first2) applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>equal</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>equal</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The two ranges are considered equal if, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). This overload of equal uses operator== to determine if two elements are equal.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>equal</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>equal</emphasis> algorithm returns true if the elements in the two ranges are equal, otherwise it returns false. If the length of the range [first1, last1) does not equal the length of the range [first2, last2), it returns false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/equal.hpp" line="229" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/equal.hpp" bodystart="229" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="equal_8hpp_1aae6a4bb3c2e497c3bf1425763047b39d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type &gt;::type hpx::parallel::v1::equal</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, Pred &amp;&amp;op=Pred())</argsstring>
        <name>equal</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns true if the range [first1, last1) is equal to the range starting at first2, and false otherwise.</para><para><simplesect kind="note"><para>Complexity: At most <emphasis>last1</emphasis> - <emphasis>first1</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>equal</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>equal</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The two ranges are considered equal if, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). This overload of equal uses operator== to determine if two elements are equal.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>equal</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>equal</emphasis> algorithm returns true if the elements in the two ranges are equal, otherwise it returns false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/equal.hpp" line="398" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/equal.hpp" bodystart="398" bodyend="413"/>
      </memberdef>
      <memberdef kind="function" id="lexicographical__compare_8hpp_1a6a8e24d8e68f80b9692b010b7d0199a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type &gt;::type hpx::parallel::v1::lexicographical_compare</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, Pred &amp;&amp;pred=Pred())</argsstring>
        <name>lexicographical_compare</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). uses a provided predicate to compare elements.</para><para><simplesect kind="note"><para>Complexity: At most 2 * min(N1, N2) applications of the comparison operation, where N1 = std::distance(first1, last) and N2 = std::distance(first2, last2).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>lexicographical_compare</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the comparison function that the first and second ranges will be applied to</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>lexicographical_compare</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>lexicographical_compare</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>Lexicographical comparison is an operation with the following properties<itemizedlist>
<listitem><para>Two ranges are compared element by element</para></listitem><listitem><para>The first mismatching element defines which range is lexicographically <emphasis>less</emphasis> or <emphasis>greater</emphasis> than the other</para></listitem><listitem><para>If one range is a prefix of another, the shorter range is lexicographically <emphasis>less</emphasis> than the other</para></listitem><listitem><para>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically <emphasis>equal</emphasis> </para></listitem><listitem><para>An empty range is lexicographically <emphasis>less</emphasis> than any non-empty range</para></listitem><listitem><para>Two empty ranges are lexicographically <emphasis>equal</emphasis> </para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="return"><para>The <emphasis>lexicographically_compare</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>lexicographically_compare</emphasis> algorithm returns true if the first range is lexicographically less, otherwise it returns false. range [first2, last2), it returns false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/lexicographical_compare.hpp" line="204" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/lexicographical_compare.hpp" bodystart="204" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="transform__reduce_8hpp_1aa9f78549181118dc94894d157027bdb7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Reduce</type>
          </param>
          <param>
            <type>typename Convert</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, T &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, T&gt;::type hpx::parallel::v1::transform_reduce</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, T init, Reduce &amp;&amp;red_op, Convert &amp;&amp;conv_op)</argsstring>
        <name>transform_reduce</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>Reduce &amp;&amp;</type>
          <declname>red_op</declname>
        </param>
        <param>
          <type>Convert &amp;&amp;</type>
          <declname>conv_op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns GENERALIZED_SUM(red_op, init, conv_op(*first), ..., conv_op(*(first + (last - first) - 1))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicates <emphasis>red_op</emphasis> and <emphasis>conv_op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Reduce</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Convert</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the unary function object used to transform the elements of the input sequence before invoking the reduce function.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv_op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">R<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. The type <emphasis>R</emphasis> must be such that an object of this type can be implicitly converted to <emphasis>T</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>red_op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values returned from the invocation of <emphasis>conv_op</emphasis>. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis>, <emphasis>Type2</emphasis>, and <emphasis>Ret</emphasis> must be such that an object of a type as returned from <emphasis>conv_op</emphasis> can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>transform_reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>transform_reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform_reduce</emphasis> algorithm returns a <emphasis>hpx::future&lt;T&gt;</emphasis> if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>T</emphasis> otherwise. The <emphasis>transform_reduce</emphasis> algorithm returns the result of the generalized sum over the values returned from <emphasis>conv_op</emphasis> when applied to the elements given by the input range [first, last).</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_SUM(op, a1, ..., aN) is defined as follows:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_SUM(op, b1, ..., bK), GENERALIZED_SUM(op, bM, ..., bN)), where:<itemizedlist>
<listitem><para>b1, ..., bN may be any permutation of a1, ..., aN and</para></listitem><listitem><para>1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>transform_reduce</emphasis> and <emphasis>accumulate</emphasis> is that the behavior of transform_reduce may be non-deterministic for non-associative or non-commutative binary predicate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform_reduce.hpp" line="254" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform_reduce.hpp" bodystart="254" bodyend="267"/>
      </memberdef>
      <memberdef kind="function" id="reduce_8hpp_1a95a48eb3dae0a9f37cd718de5001c833" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIterB</type>
          </param>
          <param>
            <type>typename FwdIterE</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, T &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, T&gt;::type &gt;::type hpx::parallel::v1::reduce</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIterB first, FwdIterE last, T init, F &amp;&amp;f)</argsstring>
        <name>reduce</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIterB</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIterE</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns GENERALIZED_SUM(f, init, *first, ..., *(first + (last - first) - 1)).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterE</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The types <emphasis>Type1</emphasis> <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIterB</emphasis> can be dereferenced and then implicitly converted to any of those types. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reduce</emphasis> algorithm returns a <emphasis>hpx::future&lt;T&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>T</emphasis> otherwise. The <emphasis>reduce</emphasis> algorithm returns the result of the generalized sum over the elements given by the input range [first, last).</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_SUM(op, a1, ..., aN) is defined as follows:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_SUM(op, b1, ..., bK), GENERALIZED_SUM(op, bM, ..., bN)), where:<itemizedlist>
<listitem><para>b1, ..., bN may be any permutation of a1, ..., aN and</para></listitem><listitem><para>1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>reduce</emphasis> and <emphasis>accumulate</emphasis> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp" line="200" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp" bodystart="200" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="reduce_8hpp_1af461ad32c26670e5dfd40e334a2d5a71" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIterB</type>
          </param>
          <param>
            <type>typename FwdIterE</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, T &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, T&gt;::type &gt;::type hpx::parallel::v1::reduce</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIterB first, FwdIterE last, T init)</argsstring>
        <name>reduce</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIterB</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIterE</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns GENERALIZED_SUM(+, init, *first, ..., *(first + (last - first) - 1)).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the operator+().</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterE</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reduce</emphasis> algorithm returns a <emphasis>hpx::future&lt;T&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>T</emphasis> otherwise. The <emphasis>reduce</emphasis> algorithm returns the result of the generalized sum (applying operator+()) over the elements given by the input range [first, last).</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_SUM(+, a1, ..., aN) is defined as follows:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_SUM(+, b1, ..., bK), GENERALIZED_SUM(+, bM, ..., bN)), where:<itemizedlist>
<listitem><para>b1, ..., bN may be any permutation of a1, ..., aN and</para></listitem><listitem><para>1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>reduce</emphasis> and <emphasis>accumulate</emphasis> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp" line="271" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp" bodystart="271" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="reduce_8hpp_1a195f09cd124dc6bd1a155f68b58e6526" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIterB</type>
          </param>
          <param>
            <type>typename FwdIterE</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; FwdIterB &gt;::value_type &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, typename std::iterator_traits&lt;FwdIterB&gt;::value_type &gt;::type &gt;::type hpx::parallel::v1::reduce</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIterB first, FwdIterE last)</argsstring>
        <name>reduce</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIterB</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIterE</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns GENERALIZED_SUM(+, T(), *first, ..., *(first + (last - first) - 1)).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the operator+().</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterE</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reduce</emphasis> algorithm returns a <emphasis>hpx::future&lt;T&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns T otherwise (where T is the value_type of <emphasis>FwdIterB</emphasis>). The <emphasis>reduce</emphasis> algorithm returns the result of the generalized sum (applying operator+()) over the elements given by the input range [first, last).</para></simplesect>
<simplesect kind="note"><para>The type of the initial value (and the result type) <emphasis>T</emphasis> is determined from the value_type of the used <emphasis>FwdIterB</emphasis>.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_SUM(+, a1, ..., aN) is defined as follows:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_SUM(+, b1, ..., bK), GENERALIZED_SUM(+, bM, ..., bN)), where:<itemizedlist>
<listitem><para>b1, ..., bN may be any permutation of a1, ..., aN and</para></listitem><listitem><para>1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>reduce</emphasis> and <emphasis>accumulate</emphasis> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp" line="344" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/reduce.hpp" bodystart="344" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__copy_8hpp_1a1c66bbb007b2e42175d491fa3ffba102" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::uninitialized_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest)</argsstring>
        <name>uninitialized_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to an uninitialized memory area beginning at <emphasis>dest</emphasis>. If an exception is thrown during the copy operation, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>uninitialized_copy</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp" line="219" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp" bodystart="219" bodyend="234"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__copy_8hpp_1a1af39d96a6c148877116acdd2716b874" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::uninitialized_copy_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, Size count, FwdIter2 dest)</argsstring>
        <name>uninitialized_copy_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest. If an exception is thrown during the copy operation, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, if count &gt; 0, no assignments otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_copy_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_copy_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>uninitialized_copy_n</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp" line="327" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_copy.hpp" bodystart="327" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2transform_8hpp_1afe123e60433fe2243f7245caf6a56776" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::transform</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>transform</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies the given function <emphasis>f</emphasis> to the range [first, last) and stores the result in another range, beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIter2</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>transform</emphasis> algorithm returns a tuple holding an iterator referring to the first element after the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform.hpp" line="304" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform.hpp" bodystart="304" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2transform_8hpp_1af7f78b7eb5dbe16a703b68aee48844b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3) &gt; &gt;::type hpx::parallel::v1::transform</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter3 dest, F &amp;&amp;f, Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>transform</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies the given function <emphasis>f</emphasis> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators for the first range used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the first sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the second sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types FwdIter1 and FwdIter2 can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIter3</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</emphasis> otherwise. The <emphasis>transform</emphasis> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform.hpp" line="625" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform.hpp" bodystart="625" bodyend="635"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2transform_8hpp_1a2c88d036a1198ebba88d54d2f7d4984b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3) &gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3) &gt; &gt;::type hpx::parallel::v1::transform</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, FwdIter3 dest, F &amp;&amp;f, Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>transform</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Applies the given function <emphasis>f</emphasis> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Exactly min(last2-first2, last1-first1) applications of <emphasis>f</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators for the first range used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the first sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function to be used for elements of the second sequence. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the second sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types FwdIter1 and FwdIter2 can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. The type <emphasis>Ret</emphasis> must be such that an object of type <emphasis>FwdIter3</emphasis> can be dereferenced and assigned a value of type <emphasis>Ret</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>transform</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="note"><para>The algorithm will invoke the binary predicate until it reaches the end of the shorter of the two given input sequences</para></simplesect>
<simplesect kind="return"><para>The <emphasis>transform</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</emphasis> otherwise. The <emphasis>transform</emphasis> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform.hpp" line="862" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform.hpp" bodystart="862" bodyend="873"/>
      </memberdef>
      <memberdef kind="function" id="inclusive__scan_8hpp_1a7d18e1d19d9f0c47b01fea61deb4af81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type hpx::parallel::v1::inclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, Op &amp;&amp;op, T init)</argsstring>
        <name>inclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, init, *first, ..., *(first + (i - result))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Ret</emphasis> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>inclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, ..., aN)) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>inclusive_scan</emphasis> is that <emphasis>inclusive_scan</emphasis> includes the ith input element in the ith sum. If <emphasis>op</emphasis> is not mathematically associative, the behavior of <emphasis>inclusive_scan</emphasis> may be non-deterministic. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp" line="288" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp" bodystart="288" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="inclusive__scan_8hpp_1a7b29dcbcbfc375cf8b2f24ee539a2c81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type hpx::parallel::v1::inclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, Op &amp;&amp;op)</argsstring>
        <name>inclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, *first, ..., *(first + (i - result))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Ret</emphasis> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>inclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aK)<itemizedlist>
<listitem><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, ..., aN) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>inclusive_scan</emphasis> is that <emphasis>inclusive_scan</emphasis> includes the ith input element in the ith sum. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp" line="511" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp" bodystart="511" bodyend="528"/>
      </memberdef>
      <memberdef kind="function" id="inclusive__scan_8hpp_1a0398fe2e741f85a40c6edfac14a75a6b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::inclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest)</argsstring>
        <name>inclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of gENERALIZED_NONCOMMUTATIVE_SUM(+, *first, ..., *(first + (i - result))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>inclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, ..., aK)<itemizedlist>
<listitem><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, ..., aN) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>inclusive_scan</emphasis> is that <emphasis>inclusive_scan</emphasis> includes the ith input element in the ith sum. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp" line="591" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/inclusive_scan.hpp" bodystart="591" bodyend="608"/>
      </memberdef>
      <memberdef kind="function" id="swap__ranges_8hpp_1ad97a105e8dafd8d11ec2d66d2d1ca2d8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::swap_ranges</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2)</argsstring>
        <name>swap_ranges</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Exchanges elements between range [first1, last1) and another range starting at <emphasis>first2</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Linear in the distance between <emphasis>first1</emphasis> and <emphasis>last1</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the swap operations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first range of iterators to swap (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second range of iterators to swap (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The swap operations in the parallel <emphasis>swap_ranges</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The swap operations in the parallel <emphasis>swap_ranges</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>swap_ranges</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>swap_ranges</emphasis> algorithm returns iterator to the element past the last element exchanged in the range beginning with <emphasis>first2</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/swap_ranges.hpp" line="130" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/swap_ranges.hpp" bodystart="130" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="set__symmetric__difference_8hpp_1a522afd8e53771d027e0c98f940986587" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter3 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type &gt;::type hpx::parallel::v1::set_symmetric_difference</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, FwdIter3 dest, Pred &amp;&amp;op=Pred())</argsstring>
        <name>set_symmetric_difference</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a sorted range beginning at dest consisting of all elements present in either of the sorted ranges [first1, last1) and [first2, last2), but not in both of them are copied to the range beginning at <emphasis>dest</emphasis>. The resulting range is also sorted. This algorithm expects both input ranges to be sorted with the given binary predicate <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <emphasis>N1</emphasis> is the length of the first sequence and <emphasis>N2</emphasis> is the length of the second sequence.</para></simplesect>
If some element is found <emphasis>m</emphasis> times in [first1, last1) and <emphasis>n</emphasis> times in [first2, last2), it will be copied to <emphasis>dest</emphasis> exactly std::abs(m-n) times. If m&gt;n, then the last m-n of those elements are copied from [first1,last1), otherwise the last n-m elements are copied from [first2,last2). The resulting range cannot overlap with either of the input ranges.</para><para>The resulting range cannot overlap with either of the input ranges.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>set_symmetric_difference</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (<emphasis>sequenced_policy</emphasis>) or in a single new thread spawned from the current thread (for <emphasis>sequenced_task_policy</emphasis>).</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>set_symmetric_difference</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter3&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter3</emphasis> otherwise. The <emphasis>set_symmetric_difference</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/set_symmetric_difference.hpp" line="215" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/set_symmetric_difference.hpp" bodystart="215" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2is__heap_8hpp_1a284adaa6f9b0e09f16df5985b9750f93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename RandIter</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type hpx::parallel::v1::is_heap</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, RandIter first, RandIter last, Comp &amp;&amp;comp=Comp(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>is_heap</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns whether the range is max heap. That is, true if the range is max heap, false otherwise. The function uses the given comparison function object <emphasis>comp</emphasis> (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: Performs at most N applications of the comparison <emphasis>comp</emphasis>, at most 2 * N applications of the projection <emphasis>proj</emphasis>, where N = last - first.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object. The return value of the INVOKE operation applied to an object of type <emphasis>Comp</emphasis>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_heap</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>is_heap</emphasis> algorithm returns whether the range is max heap. That is, true if the range is max heap, false otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp" line="215" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp" bodystart="215" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2is__heap_8hpp_1af348f9ef4c58daed9fb9cb1d057678fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename RandIter</type>
          </param>
          <param>
            <type>typename Comp</type>
            <defval>detail::less</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, RandIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type hpx::parallel::v1::is_heap_until</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, RandIter first, RandIter last, Comp &amp;&amp;comp=Comp(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>is_heap_until</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>RandIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Comp &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Comp()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the upper bound of the largest range beginning at <emphasis>first</emphasis> which is a max heap. That is, the last iterator <emphasis>it</emphasis> for which range [first, it) is a max heap. The function uses the given comparison function object <emphasis>comp</emphasis> (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: Performs at most N applications of the comparison <emphasis>comp</emphasis>, at most 2 * N applications of the projection <emphasis>proj</emphasis>, where N = last - first.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>RandIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para><emphasis>comp</emphasis> is a callable object. The return value of the INVOKE operation applied to an object of type <emphasis>Comp</emphasis>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>is_heap_until</emphasis> algorithm returns a <emphasis>hpx::future&lt;RandIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>RandIter</emphasis> otherwise. The <emphasis>is_heap_until</emphasis> algorithm returns the upper bound of the largest range beginning at first which is a max heap. That is, the last iterator <emphasis>it</emphasis> for which range [first, it) is a max heap. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp" line="414" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/is_heap.hpp" bodystart="414" bodyend="426"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2remove_8hpp_1ab6ffb9377e7396ca547d58cd1e5581d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type hpx::parallel::v1::remove_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;pred, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements for which predicate <emphasis>pred</emphasis> returns true.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>pred</emphasis> and the projection <emphasis>proj</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>remove_if</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>remove_if</emphasis> algorithm returns the iterator to the new end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/remove.hpp" line="290" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/remove.hpp" bodystart="290" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2remove_8hpp_1ae827ce96cab7f1e90de0940ee51d1378" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type hpx::parallel::v1::remove</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, T const &amp;value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements that are equal to <emphasis>value</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the operator==() and the projection <emphasis>proj</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to remove (deduced). This value type must meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the value of elements to remove. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>remove</emphasis> algorithm returns the iterator to the new end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/remove.hpp" line="367" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/remove.hpp" bodystart="367" bodyend="380"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2sort_8hpp_1a19a39eb03a906b3fc2a00a9916d3d183" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename RandomIt</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Compare</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, RandomIt &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, RandomIt&gt;::type hpx::parallel::v1::sort</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, RandomIt first, RandomIt last, Compare &amp;&amp;comp=Compare(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>sort</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>RandomIt</type>
          <declname>first</declname>
        </param>
        <param>
          <type>RandomIt</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Compare &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Compare()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: O(Nlog(N)), where N = std::distance(first, last) comparisons.</para></simplesect>
A sequence is sorted with respect to a comparator <emphasis>comp</emphasis> and a projection <emphasis>proj</emphasis> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Iter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each pair of elements as a projection operation before the actual predicate <emphasis>comp</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>sort</emphasis> algorithm returns a <emphasis>hpx::future&lt;RandomIt&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>RandomIt</emphasis> otherwise. The algorithm returns an iterator pointing to the first element after the last element in the input sequence. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/sort.hpp" line="364" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/sort.hpp" bodystart="364" bodyend="376"/>
      </memberdef>
      <memberdef kind="function" id="set__difference_8hpp_1ae4f7b86deab4d83f55ac15d4f17c720b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter3 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type &gt;::type hpx::parallel::v1::set_difference</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, FwdIter3 dest, Pred &amp;&amp;op=Pred())</argsstring>
        <name>set_difference</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a sorted range beginning at dest consisting of all elements present in the range [first1, last1) and not present in the range [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <emphasis>N1</emphasis> is the length of the first sequence and <emphasis>N2</emphasis> is the length of the second sequence.</para></simplesect>
Equivalent elements are treated individually, that is, if some element is found <emphasis>m</emphasis> times in [first1, last1) and <emphasis>n</emphasis> times in [first2, last2), it will be copied to <emphasis>dest</emphasis> exactly std::max(m-n, 0) times. The resulting range cannot overlap with either of the input ranges.</para><para>The resulting range cannot overlap with either of the input ranges.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>set_difference</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (<emphasis>sequenced_policy</emphasis>) or in a single new thread spawned from the current thread (for <emphasis>sequenced_task_policy</emphasis>).</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>set_difference</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter3&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter3</emphasis> otherwise. The <emphasis>set_difference</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/set_difference.hpp" line="203" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/set_difference.hpp" bodystart="203" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2find_8hpp_1a76c5f5c453899c36a61bfa76425b007a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type &gt;::type hpx::parallel::v1::find</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, T const &amp;val)</argsstring>
        <name>find</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the first element in the range [first, last) that is equal to value</para><para><simplesect kind="note"><para>Complexity: At most last - first applications of the operator==().</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to find (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>the value to compare the elements to</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>find</emphasis> algorithm returns the first element in the range [first,last) that is equal to <emphasis>val</emphasis>. If no such element in the range of [first,last) is equal to <emphasis>val</emphasis>, then the algorithm returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" line="173" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" bodystart="173" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2find_8hpp_1a1f66ab2a9b26ef5b5ed2c08194586b86" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type &gt;::type hpx::parallel::v1::find_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f)</argsstring>
        <name>find_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the first element in the range [first, last) for which predicate <emphasis>f</emphasis> returns true</para><para><simplesect kind="note"><para>Complexity: At most last - first applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The unary predicate which returns true for the required element. The signature of the predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>find_if</emphasis> algorithm returns the first element in the range [first,last) that satisfies the predicate <emphasis>f</emphasis>. If no such element exists that satisfies the predicate f, the algorithm returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" line="334" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" bodystart="334" bodyend="340"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2find_8hpp_1ac7aaee4759c37f4d0e83b51f313aa28d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type &gt;::type hpx::parallel::v1::find_if_not</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f)</argsstring>
        <name>find_if_not</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the first element in the range [first, last) for which predicate <emphasis>f</emphasis> returns false</para><para><simplesect kind="note"><para>Complexity: At most last - first applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The unary predicate which returns false for the required element. The signature of the predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that objects of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find_if_not</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find_if_not</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find_if_not</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>find_if_not</emphasis> algorithm returns the first element in the range [first, last) that does <bold>not</bold> satisfy the predicate <emphasis>f</emphasis>. If no such element exists that does not satisfy the predicate f, the algorithm returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" line="500" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" bodystart="500" bodyend="506"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2find_8hpp_1a59ea9f8ce4b447a377d4d78ef2dbd2b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter1 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter1&gt;::type &gt;::type hpx::parallel::v1::find_end</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, Pred &amp;&amp;op=Pred(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>find_end</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the last subsequence of elements [first2, last2) found in the range [first, last) using the given predicate <emphasis>f</emphasis> to compare elements.</para><para><simplesect kind="note"><para>Complexity: at most S*(N-S+1) comparisons where <emphasis>S</emphasis> = distance(first2, last2) and <emphasis>N</emphasis> = distance(first1, last1).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>replace</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of type dereferenced <emphasis>FwdIter1</emphasis> and dereferenced <emphasis>FwdIter2</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns <emphasis>true</emphasis> if the elements should be treated as equal. The signature should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter1</emphasis> and dereferenced <emphasis>FwdIter2</emphasis> as a projection operation before the function <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find_end</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find_end</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find_end</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>find_end</emphasis> algorithm returns an iterator to the beginning of the last subsequence [first2, last2) in range [first, last). If the length of the subsequence [first2, last2) is greater than the length of the range [first1, last1), <emphasis>last1</emphasis> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <emphasis>last1</emphasis> is also returned.</para></simplesect>
This overload of <emphasis>find_end</emphasis> is available if the user decides to provide the algorithm their own predicate <emphasis>f</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" line="703" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" bodystart="703" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2find_8hpp_1a9a2a32b88ef22a7af9c9009eac33c6de" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj1</type>
            <defval>util::projection_identity</defval>
          </param>
          <param>
            <type>typename Proj2</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter1 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter1&gt;::type &gt;::type hpx::parallel::v1::find_first_of</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 s_first, FwdIter2 s_last, Pred &amp;&amp;op=Pred(), Proj1 &amp;&amp;proj1=Proj1(), Proj2 &amp;&amp;proj2=Proj2())</argsstring>
        <name>find_first_of</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>s_first</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>s_last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj1 &amp;&amp;</type>
          <declname>proj1</declname>
          <defval>Proj1()</defval>
        </param>
        <param>
          <type>Proj2 &amp;&amp;</type>
          <declname>proj2</declname>
          <defval>Proj2()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses binary predicate p to compare elements</para><para><simplesect kind="note"><para>Complexity: at most (S*N) comparisons where <emphasis>S</emphasis> = distance(s_first, s_last) and <emphasis>N</emphasis> = distance(first, last).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of type dereferenced <emphasis>FwdIter1</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> and is applied to the elements of type dereferenced <emphasis>FwdIter2</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s_last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the algorithm will be searching for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns <emphasis>true</emphasis> if the elements should be treated as equal. The signature should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj1</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter1</emphasis> as a projection operation before the function <emphasis>op</emphasis> is invoked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj2</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <emphasis>FwdIter2</emphasis> as a projection operation before the function <emphasis>op</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>find_first_of</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>find_first_of</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>find_first_of</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter1&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter1</emphasis> otherwise. The <emphasis>find_first_of</emphasis> algorithm returns an iterator to the first element in the range [first, last) that is equal to an element from the range [s_first, s_last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <emphasis>last</emphasis> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <emphasis>last</emphasis> is also returned. This overload of <emphasis>find_end</emphasis> is available if the user decides to provide the algorithm their own predicate <emphasis>f</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" line="926" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/find.hpp" bodystart="926" bodyend="944"/>
      </memberdef>
      <memberdef kind="function" id="transform__inclusive__scan_8hpp_1afa7b5c6696fe051a8871ee813c88c255" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
          <param>
            <type>typename Conv</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type hpx::parallel::v1::transform_inclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, Op &amp;&amp;op, Conv &amp;&amp;conv, T init)</argsstring>
        <name>transform_inclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>Conv &amp;&amp;</type>
          <declname>conv</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, init, conv(*first), ..., conv(*(first + (i - result)))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Conv</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the unary function object used for the conversion operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">R<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to Type. The type <emphasis>R</emphasis> must be such that an object of this type can be implicitly converted to <emphasis>T</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Ret</emphasis> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>transform_inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>transform_inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>transform_inclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, ..., aN)) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></simplesect>
Neither <emphasis>conv</emphasis> nor <emphasis>op</emphasis> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).</para><para>The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>transform_inclusive_scan</emphasis> is that <emphasis>transform_inclusive_scan</emphasis> includes the ith input element in the ith sum. If <emphasis>op</emphasis> is not mathematically associative, the behavior of <emphasis>transform_inclusive_scan</emphasis> may be non-deterministic. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp" line="320" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp" bodystart="320" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="transform__inclusive__scan_8hpp_1a9485c4191609660bd226d64a7d53df78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Conv</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type hpx::parallel::v1::transform_inclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, Op &amp;&amp;op, Conv &amp;&amp;conv)</argsstring>
        <name>transform_inclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <param>
          <type>Conv &amp;&amp;</type>
          <declname>conv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, conv(*first), ..., conv(*(first + (i - result)))).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Conv</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the unary function object used for the conversion operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">R<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to Type. The type <emphasis>R</emphasis> must be such that an object of this type can be implicitly converted to <emphasis>T</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Ret</emphasis> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>transform_inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>transform_inclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>transform_inclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, ..., aN)) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></simplesect>
Neither <emphasis>conv</emphasis> nor <emphasis>op</emphasis> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).</para><para>The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>transform_inclusive_scan</emphasis> is that <emphasis>transform_inclusive_scan</emphasis> includes the ith input element in the ith sum. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp" line="445" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform_inclusive_scan.hpp" bodystart="445" bodyend="455"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__value__construct_8hpp_1a30a4fcff72d61a5c69d24d1982d6b2b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy&gt;::type hpx::parallel::v1::uninitialized_value_construct</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last)</argsstring>
        <name>uninitialized_value_construct</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, last) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_value_construct</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_value_construct</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_value_construct</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>void</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp" line="209" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp" bodystart="209" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__value__construct_8hpp_1a26fb2b43578429cf5bcf837fe4be24cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::uninitialized_value_construct_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count)</argsstring>
        <name>uninitialized_value_construct_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, first + count) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, if count &gt; 0, no assignments otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_value_construct_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_value_construct_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_value_construct_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>uninitialized_value_construct_n</emphasis> algorithm returns the iterator to the element in the source range, one past the last element constructed. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp" line="334" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_value_construct.hpp" bodystart="334" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="includes_8hpp_1a3ab31b809075cedeedb2fa9ef05a55e5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, bool &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, bool&gt;::type &gt;::type hpx::parallel::v1::includes</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, Pred &amp;&amp;op=Pred())</argsstring>
        <name>includes</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns true if every element from the sorted range [first2, last2) is found within the sorted range [first1, last1). Also returns true if [first2, last2) is empty. The version expects both ranges to be sorted with the user supplied binary predicate <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>At most 2*(N1+N2-1) comparisons, where N1 = std::distance(first1, last1) and N2 = std::distance(first2, last2).</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>includes</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as includes. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter1</emphasis> and <emphasis>FwdIter2</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> respectively</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparison operations in the parallel <emphasis>includes</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The comparison operations in the parallel <emphasis>includes</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>includes</emphasis> algorithm returns a <emphasis>hpx::future&lt;bool&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>bool</emphasis> otherwise. The <emphasis>includes</emphasis> algorithm returns true every element from the sorted range [first2, last2) is found within the sorted range [first1, last1). Also returns true if [first2, last2) is empty. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/includes.hpp" line="289" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/includes.hpp" bodystart="289" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2reverse_8hpp_1a967582e2015a58617a450103228c2830" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename BidirIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, BidirIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, BidirIter&gt;::type hpx::parallel::v1::reverse</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, BidirIter first, BidirIter last)</argsstring>
        <name>reverse</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>BidirIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>BidirIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reverses the order of the elements in the range [first, last). Behaves as if applying std::iter_swap to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.</para><para><simplesect kind="note"><para>Complexity: Linear in the distance between <emphasis>first</emphasis> and <emphasis>last</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BidirIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>reverse</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>reverse</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reverse</emphasis> algorithm returns a <emphasis>hpx::future&lt;BidirIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>BidirIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp" line="127" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp" bodystart="127" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2reverse_8hpp_1a540985b828bcf4b522c9a9df67fcb29b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename BidirIter</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(BidirIter), tag::out(FwdIter)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt; &gt;::type hpx::parallel::v1::reverse_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, BidirIter first, BidirIter last, FwdIter dest_first)</argsstring>
        <name>reverse_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>BidirIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>BidirIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>dest_first</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements from the range [first, last) to another range beginning at dest_first in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment *(dest_first + (last - first) - 1 - i) = *(first + i) once for each non-negative i &lt; (last - first) If the source and destination ranges (that is, [first, last) and [dest_first, dest_first+(last-first)) respectively) overlap, the behavior is undefined.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BidirIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the begin of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>reverse_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>reverse_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>reverse_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp" line="261" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/reverse.hpp" bodystart="261" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="adjacent__difference_8hpp_1a5aa9e2c155c1c458889ad7b38be140e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::adjacent_difference</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest)</argsstring>
        <name>adjacent_difference</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns each value in the range given by result its corresponding element in the range [first, last] and the one preceding it except *result, which is assigned *first</para><para><simplesect kind="note"><para>Complexity: Exactly (last - first) - 1 application of the binary operator and (last - first) assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the input range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the output range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the results will be assigned to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The difference operations in the parallel <emphasis>adjacent_difference</emphasis> invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The difference operations in the parallel <emphasis>adjacent_difference</emphasis> invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>adjacent_difference</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>adjacent_find</emphasis> algorithm returns an iterator to the last element in the output range.</para></simplesect>
This overload of <emphasis>adjacent_find</emphasis> is available if the user decides to provide their algorithm their own binary predicate <emphasis>op</emphasis>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp" line="194" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp" bodystart="194" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="adjacent__difference_8hpp_1acc00da8b1642d026540fc4fb5256ec68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::adjacent_difference</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, Op &amp;&amp;op)</argsstring>
        <name>adjacent_difference</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns each value in the range given by result its corresponding element in the range [first, last] and the one preceding it except *result, which is assigned *first</para><para><simplesect kind="note"><para>Complexity: Exactly (last - first) - 1 application of the binary operator and (last - first) assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the input range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used for the output range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>adjacent_difference</emphasis> requires <emphasis>Op</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the results will be assigned to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary operator which returns the difference of elements. The signature should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>op(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> must be such that objects of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to the dereferenced type of <emphasis>dest</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The difference operations in the parallel <emphasis>adjacent_difference</emphasis> invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The difference operations in the parallel <emphasis>adjacent_difference</emphasis> invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>adjacent_difference</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>adjacent_find</emphasis> algorithm returns an iterator to the last element in the output range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp" line="275" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/adjacent_difference.hpp" bodystart="275" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__default__construct_8hpp_1a0d3350b1ae15721218ff2578988fb3f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy&gt;::type hpx::parallel::v1::uninitialized_default_construct</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last)</argsstring>
        <name>uninitialized_default_construct</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, last) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_default_construct</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_default_construct</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_default_construct</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>void</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp" line="208" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp" bodystart="208" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="uninitialized__default__construct_8hpp_1a2090d59706bbdecf6463dc8419d94d7b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::uninitialized_default_construct_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count)</argsstring>
        <name>uninitialized_default_construct_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, first + count) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, if count &gt; 0, no assignments otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>uninitialized_default_construct_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>uninitialized_default_construct_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>uninitialized_default_construct_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>uninitialized_default_construct_n</emphasis> algorithm returns the iterator to the element in the source range, one past the last element constructed. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp" line="334" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/uninitialized_default_construct.hpp" bodystart="334" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2count_8hpp_1a5fbba94cfc78cec26b3566885739a679" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIterB</type>
          </param>
          <param>
            <type>typename FwdIterE</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; FwdIterB &gt;::difference_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt;FwdIterB&gt;::difference_type &gt;::type hpx::parallel::v1::count</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIterB first, FwdIterE last, T const &amp;value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>count</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIterB</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIterE</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts the elements that are equal to the given <emphasis>value</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> comparisons.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterE</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to search for (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to search for. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The comparisons in the parallel <emphasis>count</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para><simplesect kind="note"><para>The comparisons in the parallel <emphasis>count</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>count</emphasis> algorithm returns a <emphasis>hpx::future&lt;difference_type&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>std::iterator_traits&lt;FwdIterB&gt;::difference_type</emphasis>. The <emphasis>count</emphasis> algorithm returns the number of elements satisfying the given criteria. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/count.hpp" line="259" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/count.hpp" bodystart="259" bodyend="271"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2count_8hpp_1a8d5bf8ecd26017800facc01641bbb78f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIterB</type>
          </param>
          <param>
            <type>typename FwdIterE</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt; FwdIterB &gt;::difference_type &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, typename std::iterator_traits&lt;FwdIterB&gt;::difference_type &gt;::type hpx::parallel::v1::count_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIterB first, FwdIterE last, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>count_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIterB</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIterE</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts elements for which predicate <emphasis>f</emphasis> returns true.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterB</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIterE</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>count_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIterB</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The assignments in the parallel <emphasis>count_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread. </para></simplesect>
<simplesect kind="note"><para>The assignments in the parallel <emphasis>count_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para></simplesect>
<simplesect kind="return"><para>The <emphasis>count_if</emphasis> algorithm returns <emphasis>hpx::future&lt;difference_type&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>difference_type</emphasis> otherwise (where <emphasis>difference_type</emphasis> is defined by <emphasis>std::iterator_traits&lt;FwdIterB&gt;::difference_type</emphasis>. The <emphasis>count</emphasis> algorithm returns the number of elements satisfying the given criteria. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/count.hpp" line="451" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/count.hpp" bodystart="451" bodyend="463"/>
      </memberdef>
      <memberdef kind="function" id="destroy_8hpp_1a70065cb704eb09d1fa9328763fe358d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy&gt;::type hpx::parallel::v1::destroy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last)</argsstring>
        <name>destroy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroys objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the range [first, last).</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> operations.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The operations in the parallel <emphasis>destroy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The operations in the parallel <emphasis>destroy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>destroy</emphasis> algorithm returns a <emphasis>hpx::future&lt;void&gt;</emphasis>, if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>void</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp" line="152" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp" bodystart="152" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="destroy_8hpp_1abe254a1d5dfcac6f794487708b10f63a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::destroy_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, Size count)</argsstring>
        <name>destroy_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroys objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the range [first, first + count).</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> operations, if count &gt; 0, no assignments otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply this algorithm to.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to.</para></parameterdescription>
</parameteritem>
</parameterlist>
The operations in the parallel <emphasis>destroy_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The operations in the parallel <emphasis>destroy_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>destroy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>destroy_n</emphasis> algorithm returns the iterator to the element in the source range, one past the last element constructed. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp" line="264" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/destroy.hpp" bodystart="264" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2partition_8hpp_1a51d223e340c4841518fee0e95a68e426" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename BidirIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, BidirIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, BidirIter&gt;::type hpx::parallel::v1::stable_partition</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, BidirIter first, BidirIter last, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>stable_partition</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>BidirIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>BidirIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Permutes the elements in the range [first, last) such that there exists an iterator i such that for every iterator j in the range [first, i) INVOKE(f, INVOKE (proj, *j)) != false, and for every iterator k in the range [i, last), INVOKE(f, INVOKE (proj, *k)) == false</para><para><simplesect kind="note"><para>Complexity: At most (last - first) * log(last - first) swaps, but only linear number of swaps if there is enough extra memory. Exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate and projection.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <emphasis>f</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BidirIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>transform</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Unary predicate which returns true if the element should be ordered before other elements. Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>fun(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>BidirIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>f</emphasis> is invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The invocations of <emphasis>f</emphasis> in the parallel <emphasis>stable_partition</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> executes in sequential order in the calling thread.</para><para>The invocations of <emphasis>f</emphasis> in the parallel <emphasis>stable_partition</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>stable_partition</emphasis> algorithm returns an iterator i such that for every iterator j in the range [first, i), f(*j) != false INVOKE(f, INVOKE(proj, *j)) != false, and for every iterator k in the range [i, last), f(*k) == false INVOKE(f, INVOKE (proj, *k)) == false. The relative order of the elements in both groups is preserved. If the execution policy is of type <emphasis>parallel_task_policy</emphasis> the algorithm returns a future&lt;&gt; referring to this iterator. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/partition.hpp" line="292" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/partition.hpp" bodystart="292" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2partition_8hpp_1a3ab0c3141a7e949ac7e4e0941dfc2af4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type hpx::parallel::v1::partition</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;pred, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>partition</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reorders the elements in the range [first, last) in such a way that all elements for which the predicate <emphasis>pred</emphasis> returns true precede the elements for which the predicate <emphasis>pred</emphasis> returns false. Relative order of the elements is not preserved.</para><para><simplesect kind="note"><para>Complexity: At most 2 * (last - first) swaps. Exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate and projection.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>partition</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>partition</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>partition</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>partition</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>partition</emphasis> algorithm returns the iterator to the first element of the second group. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/partition.hpp" line="1065" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/partition.hpp" bodystart="1065" bodyend="1078"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2partition_8hpp_1a4cd508247887a0638c69812cdcb16b96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename Pred</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in(FwdIter1), tag::out1(FwdIter2), tag::out2(FwdIter3)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_tuple&lt; tag::in(FwdIter1), tag::out1(FwdIter2), tag::out2(FwdIter3)&gt; &gt;::type hpx::parallel::v1::partition_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest_true, FwdIter3 dest_false, Pred &amp;&amp;pred, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>partition_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest_true</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest_false</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to two different ranges depending on the value returned by the predicate <emphasis>pred</emphasis>. The elements, that satisfy the predicate <emphasis>pred</emphasis>, are copied to the range beginning at <emphasis>dest_true</emphasis>. The rest of the elements are copied to the range beginning at <emphasis>dest_false</emphasis>. The order of the elements is preserved.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range for the elements that satisfy the predicate <emphasis>pred</emphasis> (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range for the elements that don&apos;t satisfy the predicate <emphasis>pred</emphasis> (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>partition_copy</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_true</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range for the elements that satisfy the predicate <emphasis>pred</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest_false</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range for the elements that don&apos;t satisfy the predicate <emphasis>pred</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>partition_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>partition_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>partition_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</emphasis> otherwise. The <emphasis>partition_copy</emphasis> algorithm returns the tuple of the source iterator <emphasis>last</emphasis>, the destination iterator to the end of the <emphasis>dest_true</emphasis> range, and the destination iterator to the end of the <emphasis>dest_false</emphasis> range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/partition.hpp" line="1352" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/partition.hpp" bodystart="1352" bodyend="1374"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2copy_8hpp_1a22a7a61f1a245998f3dfb5905a165ba2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest)</argsstring>
        <name>copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to another range beginning at <emphasis>dest</emphasis>.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/copy.hpp" line="209" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/copy.hpp" bodystart="209" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2copy_8hpp_1a6d350049604581b94b5f2be53f44de3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename Size</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::copy_n</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, Size count, FwdIter2 dest)</argsstring>
        <name>copy_n</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>Size</type>
          <declname>count</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest.</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>count</emphasis> assignments, if count &gt; 0, no assignments otherwise.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Size</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the argument specifying the number of elements to apply <emphasis>f</emphasis> to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the number of elements starting at <emphasis>first</emphasis> the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>copy_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>copy_n</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/copy.hpp" line="330" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/copy.hpp" bodystart="330" bodyend="356"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2copy_8hpp_1ad89029658c0519f9fa9ad90ec4e6301c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::copy_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>copy_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to another range beginning at <emphasis>dest</emphasis>. Copies only the elements for which the predicate <emphasis>f</emphasis> returns true. The order of the elements that are not removed is preserved.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/copy.hpp" line="585" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/copy.hpp" bodystart="585" bodyend="602"/>
      </memberdef>
      <memberdef kind="function" id="exclusive__scan_8hpp_1a1470fceceb3fd845bc561c8435a94685" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::exclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, T init, Op &amp;&amp;op)</argsstring>
        <name>exclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(binary_op, init, *first, ..., *(first + (i - result) - 1)).</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the reduction operation.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Ret</emphasis> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>exclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>exclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>exclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, ..., aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, ..., aN)) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>inclusive_scan</emphasis> is that <emphasis>inclusive_scan</emphasis> includes the ith input element in the ith sum. If <emphasis>op</emphasis> is not mathematically associative, the behavior of <emphasis>inclusive_scan</emphasis> may be non-deterministic. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp" line="292" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp" bodystart="292" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="exclusive__scan_8hpp_1a064ea3f7e2564c51f7aa41b41ea5adeb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter2 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type &gt;::type hpx::parallel::v1::exclusive_scan</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, T init)</argsstring>
        <name>exclusive_scan</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Assigns through each iterator <emphasis>i</emphasis> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(+, init, *first, ..., *(first + (i - result) - 1))</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>std::plus&lt;T&gt;</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as initial (and intermediate) values (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the generalized sum.</para></parameterdescription>
</parameteritem>
</parameterlist>
The reduce operations in the parallel <emphasis>exclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The reduce operations in the parallel <emphasis>exclusive_scan</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>copy_n</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter2&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter2</emphasis> otherwise. The <emphasis>exclusive_scan</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</para></simplesect>
<simplesect kind="note"><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, ..., aN) is defined as:<itemizedlist>
<listitem><para>a1 when N is 1</para></listitem><listitem><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, ..., aK)<itemizedlist>
<listitem><para>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, ..., aN) where 1 &lt; K+1 = M &lt;= N.</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></simplesect>
The difference between <emphasis>exclusive_scan</emphasis> and <emphasis>inclusive_scan</emphasis> is that <emphasis>inclusive_scan</emphasis> includes the ith input element in the ith sum. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp" line="374" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/exclusive_scan.hpp" bodystart="374" bodyend="390"/>
      </memberdef>
      <memberdef kind="function" id="set__intersection_8hpp_1add12fab06f2d2d3ed748b43f4de79a99" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename FwdIter3</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; execution::is_execution_policy&lt; ExPolicy &gt;::value, typename util::detail::algorithm_result&lt; ExPolicy, FwdIter3 &gt;::type &gt;::type</type>
        <definition>std::enable_if&lt; execution::is_execution_policy&lt;ExPolicy&gt;::value, typename util::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type &gt;::type hpx::parallel::v1::set_intersection</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, FwdIter2 last2, FwdIter3 dest, Pred &amp;&amp;op=Pred())</argsstring>
        <name>set_intersection</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>last2</declname>
        </param>
        <param>
          <type>FwdIter3</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>op</declname>
          <defval>Pred()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructs a sorted range beginning at dest consisting of all elements present in both sorted ranges [first1, last1) and [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <emphasis>f</emphasis>.</para><para><simplesect kind="note"><para>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <emphasis>N1</emphasis> is the length of the first sequence and <emphasis>N2</emphasis> is the length of the second sequence.</para></simplesect>
If some element is found <emphasis>m</emphasis> times in [first1, last1) and <emphasis>n</emphasis> times in [first2, last2), the first std::min(m, n) elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.</para><para>The resulting range cannot overlap with either of the input ranges.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter3</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <emphasis>set_intersection</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::less&lt;&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type <emphasis>Type1</emphasis> must be such that objects of type <emphasis>InIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type1</emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (<emphasis>sequenced_policy</emphasis>) or in a single new thread spawned from the current thread (for <emphasis>sequenced_task_policy</emphasis>).</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>set_intersection</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter3&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter3</emphasis> otherwise. The <emphasis>set_intersection</emphasis> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/set_intersection.hpp" line="189" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/set_intersection.hpp" bodystart="189" bodyend="211"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2unique_8hpp_1ae64d84bb7aed7c2381b1fd0e10b7018e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type hpx::parallel::v1::unique</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, Pred &amp;&amp;pred=Pred(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>unique</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Eliminates all but the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> - 1 applications of the predicate <emphasis>pred</emphasis> and no more than twice as many applications of the projection <emphasis>proj</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>unique</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> must be such that objects of types <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to both <emphasis>Type1</emphasis> and <emphasis>Type2</emphasis> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>unique</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>unique</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>unique</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. The <emphasis>unique</emphasis> algorithm returns the iterator to the new end of the range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/unique.hpp" line="311" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/unique.hpp" bodystart="311" bodyend="324"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2unique_8hpp_1aabe3817149521a1a7e7384dba5bd68b9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename Pred</type>
            <defval>detail::equal_to</defval>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::unique_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, Pred &amp;&amp;pred=Pred(), Proj &amp;&amp;proj=Proj())</argsstring>
        <name>unique_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>Pred &amp;&amp;</type>
          <declname>pred</declname>
          <defval>Pred()</defval>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements from the range [first, last), to another range beginning at <emphasis>dest</emphasis> in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> - 1 applications of the predicate <emphasis>pred</emphasis> and no more than twice as many applications of the projection <emphasis>proj</emphasis> </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Pred</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>unique_copy</emphasis> requires <emphasis>Pred</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. This defaults to std::equal_to&lt;&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <emphasis>true</emphasis> for the required elements. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a,<sp/>const<sp/>Type<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>unique_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>unique_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>unique_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>unique_copy</emphasis> algorithm returns the pair of the source iterator to <emphasis>last</emphasis>, and the destination iterator to the end of the <emphasis>dest</emphasis> range. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/unique.hpp" line="612" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/unique.hpp" bodystart="612" bodyend="630"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2replace_8hpp_1a2a8af54cd1078cc756853a5f5fdf4550" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::replace</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, T1 const &amp;old_value, T2 const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T1 const &amp;</type>
          <declname>old_value</declname>
        </param>
        <param>
          <type>T2 const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replaces all elements satisfying specific criteria with <emphasis>new_value</emphasis> in the range [first, last).</para><para>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(proj, *it) == old_value</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the old value to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the old value of the elements to replace. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>void</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" line="164" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" bodystart="164" bodyend="176"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2replace_8hpp_1a2e9ea84f6ce4d49680ade7b6b0be95c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, FwdIter &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type hpx::parallel::v1::replace_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter first, FwdIter last, F &amp;&amp;f, T const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter</type>
          <declname>last</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Replaces all elements satisfying specific criteria (for which predicate <emphasis>f</emphasis> returns true) with <emphasis>new_value</emphasis> in the range [first, last).</para><para>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(f, INVOKE(proj, *it)) != false</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the elements which need to replaced. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;FwdIter&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>FwdIter</emphasis> otherwise. It returns <emphasis>last</emphasis>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" line="326" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" bodystart="326" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2replace_8hpp_1aed5a912dfc682304b9096953eb3854dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T1</type>
          </param>
          <param>
            <type>typename T2</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::replace_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, T1 const &amp;old_value, T2 const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T1 const &amp;</type>
          <declname>old_value</declname>
        </param>
        <param>
          <type>T2 const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the all elements from the range [first, last) to another range beginning at <emphasis>dest</emphasis> replacing all elements satisfying a specific criteria with <emphasis>new_value</emphasis>.</para><para>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(proj, *(first + (i - result))) == old_value</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the old value to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the old value of the elements to replace. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" line="493" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" bodystart="493" bodyend="510"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2replace_8hpp_1a0e77ebdd9607ee75e91f60109ac7a0e7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::replace_copy_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, F &amp;&amp;f, T const &amp;new_value, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>replace_copy_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>new_value</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the all elements from the range [first, last) to another range beginning at <emphasis>dest</emphasis> replacing all elements satisfying a specific criteria with <emphasis>new_value</emphasis>.</para><para>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(f, INVOKE(proj, *(first + (i - result)))) != false</para><para><simplesect kind="note"><para>Complexity: Performs exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>equal</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the new values to replace (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the elements which need to replaced. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to <emphasis>Type</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>new_value</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the new value to use as the replacement. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>replace_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>replace_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>replace_copy_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>replace_copy_if</emphasis> algorithm returns the input iterator <emphasis>last</emphasis> and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" line="683" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/replace.hpp" bodystart="683" bodyend="700"/>
      </memberdef>
      <memberdef kind="function" id="transform__reduce__binary_8hpp_1a693dae27f2f4fa48464229112b73ae56" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, T &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, T&gt;::type hpx::parallel::v1::transform_reduce</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, T init)</argsstring>
        <name>transform_reduce</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the result of accumulating init with the inner products of the pairs formed by the elements of two ranges starting at first1 and first2.</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op2</emphasis>. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as return) values (deduced). </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first sequence of elements the result will be calculated with. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second sequence of elements the result will be calculated with. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the sum.</para></parameterdescription>
</parameteritem>
</parameterlist>
The operations in the parallel <emphasis>transform_reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The operations in the parallel <emphasis>transform_reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform_reduce</emphasis> algorithm returns a <emphasis>hpx::future&lt;T&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>T</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp" line="323" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp" bodystart="323" bodyend="330"/>
      </memberdef>
      <memberdef kind="function" id="transform__reduce__binary_8hpp_1ad0241a6affe0562bc8b0ccedc8a5af6b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Reduce</type>
          </param>
          <param>
            <type>typename Convert</type>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, T &gt;::type</type>
        <definition>util::detail::algorithm_result&lt;ExPolicy, T&gt;::type hpx::parallel::v1::transform_reduce</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first1, FwdIter1 last1, FwdIter2 first2, T init, Reduce &amp;&amp;red_op, Convert &amp;&amp;conv_op)</argsstring>
        <name>transform_reduce</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>Reduce &amp;&amp;</type>
          <declname>red_op</declname>
        </param>
        <param>
          <type>Convert &amp;&amp;</type>
          <declname>conv_op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the result of accumulating init with the inner products of the pairs formed by the elements of two ranges starting at first1 and first2.</para><para><simplesect kind="note"><para>Complexity: O(<emphasis>last</emphasis> - <emphasis>first</emphasis>) applications of the predicate <emphasis>op2</emphasis>. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the first source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the second source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value to be used as return) values (deduced). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Reduce</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the binary function object used for the multiplication operation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Convert</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the unary function object used to transform the elements of the input sequence before invoking the reduce function.</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the first sequence of elements the result will be calculated with. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the first sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the second sequence of elements the result will be calculated with. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The initial value for the sum. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>red_op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for the initial value and each of the return values of <emphasis>op2</emphasis>. This is a binary predicate. The signature of this predicate should be equivalent to should be equivalent to: <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type1<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Ret</emphasis> must be such that it can be implicitly converted to a type of <emphasis>T</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conv_op</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the input values of the sequence. This is a binary predicate. The signature of this predicate should be equivalent to <programlisting><codeline><highlight class="normal">Ret<sp/>fun(const<sp/>Type1<sp/>&amp;a,<sp/>const<sp/>Type2<sp/>&amp;b);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Ret</emphasis> must be such that it can be implicitly converted to an object for the second argument type of <emphasis>op1</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
The operations in the parallel <emphasis>transform_reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The operations in the parallel <emphasis>transform_reduce</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>transform_reduce</emphasis> algorithm returns a <emphasis>hpx::future&lt;T&gt;</emphasis> if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>T</emphasis> otherwise. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp" line="432" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/transform_reduce_binary.hpp" bodystart="432" bodyend="440"/>
      </memberdef>
      <memberdef kind="function" id="sort__by__key_8hpp_1a4654311fbeb730ed3fbae60c48987150" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename KeyIter</type>
          </param>
          <param>
            <type>typename ValueIter</type>
          </param>
          <param>
            <type>typename Compare</type>
            <defval>detail::less</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in1(KeyIter), tag::in2(ValueIter)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in1(KeyIter), tag::in2(ValueIter)&gt; &gt;::type hpx::parallel::v1::sort_by_key</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, KeyIter key_first, KeyIter key_last, ValueIter value_first, Compare &amp;&amp;comp=Compare())</argsstring>
        <name>sort_by_key</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>KeyIter</type>
          <declname>key_first</declname>
        </param>
        <param>
          <type>KeyIter</type>
          <declname>key_last</declname>
        </param>
        <param>
          <type>ValueIter</type>
          <declname>value_first</declname>
        </param>
        <param>
          <type>Compare &amp;&amp;</type>
          <declname>comp</declname>
          <defval>Compare()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sorts one range of data using keys supplied in another range. The key elements in the range [key_first, key_last) are sorted in ascending order with the corresponding elements in the value range moved to follow the sorted order. The algorithm is not stable, the order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</para><para><simplesect kind="note"><para>Complexity: O(Nlog(N)), where N = std::distance(first, last) comparisons.</para></simplesect>
A sequence is sorted with respect to a comparator <emphasis>comp</emphasis> and a projection <emphasis>proj</emphasis> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.</para><para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>KeyIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the key iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ValueIter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the value iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced).</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of key elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>key_last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of key elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of value elements the algorithm will be applied to, the range of elements must match [key_first, key_last) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator.</para></parameterdescription>
</parameteritem>
</parameterlist>
<emphasis>comp</emphasis> has to induce a strict weak ordering on the values.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The application of function objects in parallel algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>sort_by-key</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in1(KeyIter&gt;</emphasis>, tag::in2(ValueIter)&gt; &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis><emphasis>tagged_pair&lt;tag::in1(KeyIter), tag::in2(ValueIter)&gt;</emphasis> otherwise</emphasis>. The algorithm returns a pair holding an iterator pointing to the first element after the last element in the input key sequence and an iterator pointing to the first element after the last element in the input value sequence. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/sort_by_key.hpp" line="125" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/sort_by_key.hpp" bodystart="125" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2remove__copy_8hpp_1adb30c2cd504c8d1860eac328ebdab75f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::remove_copy</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, T const &amp;val, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove_copy</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>T const &amp;</type>
          <declname>val</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to another range beginning at <emphasis>dest</emphasis>. Copies only the elements for which the comparison operator returns false when compare to val. The order of the elements that are not removed is preserved.</para><para>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(proj, *it) == value</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type that the result of dereferencing FwdIter1 is compared to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>val</parametername>
</parameternamelist>
<parameterdescription>
<para>Value to be removed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove_copy</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove_copy</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp" line="173" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp" bodystart="173" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="algorithms_2remove__copy_8hpp_1a5423d1998cd9627340234b1dc4d59aa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ExPolicy</type>
          </param>
          <param>
            <type>typename FwdIter1</type>
          </param>
          <param>
            <type>typename FwdIter2</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename Proj</type>
            <defval>util::projection_identity</defval>
          </param>
        </templateparamlist>
        <type>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt; tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type</type>
        <definition>util::detail::algorithm_result&lt; ExPolicy, hpx::util::tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt; &gt;::type hpx::parallel::v1::remove_copy_if</definition>
        <argsstring>(ExPolicy &amp;&amp;policy, FwdIter1 first, FwdIter1 last, FwdIter2 dest, F &amp;&amp;f, Proj &amp;&amp;proj=Proj())</argsstring>
        <name>remove_copy_if</name>
        <param>
          <type>ExPolicy &amp;&amp;</type>
          <declname>policy</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>first</declname>
        </param>
        <param>
          <type>FwdIter1</type>
          <declname>last</declname>
        </param>
        <param>
          <type>FwdIter2</type>
          <declname>dest</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>Proj &amp;&amp;</type>
          <declname>proj</declname>
          <defval>Proj()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies the elements in the range, defined by [first, last), to another range beginning at <emphasis>dest</emphasis>. Copies only the elements for which the predicate <emphasis>f</emphasis> returns false. The order of the elements that are not removed is preserved.</para><para>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(pred, INVOKE(proj, *it)) != false.</para><para><simplesect kind="note"><para>Complexity: Performs not more than <emphasis>last</emphasis> - <emphasis>first</emphasis> assignments, exactly <emphasis>last</emphasis> - <emphasis>first</emphasis> applications of the predicate <emphasis>f</emphasis>.</para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ExPolicy</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter1</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FwdIter2</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <emphasis>copy_if</emphasis> requires <emphasis>F</emphasis> to meet the requirements of <emphasis>CopyConstructible</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Proj</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of an optional projection function. This defaults to <emphasis><ref refid="structhpx_1_1parallel_1_1util_1_1projection__identity" kindref="compound">util::projection_identity</ref></emphasis> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>policy</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution policy to use for the scheduling of the iterations. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the end of the sequence of elements the algorithm will be applied to. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dest</parametername>
</parameternamelist>
<parameterdescription>
<para>Refers to the beginning of the destination range. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <emphasis>true</emphasis> for the elements to be removed. The signature of this predicate should be equivalent to: <programlisting><codeline><highlight class="normal">bool<sp/>pred(const<sp/>Type<sp/>&amp;a);</highlight></codeline>
</programlisting> <linebreak/>
 The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type <emphasis>Type</emphasis> must be such that an object of type <emphasis>FwdIter1</emphasis> can be dereferenced and then implicitly converted to Type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>proj</parametername>
</parameternamelist>
<parameterdescription>
<para>Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <emphasis>is</emphasis> invoked.</para></parameterdescription>
</parameteritem>
</parameterlist>
The assignments in the parallel <emphasis>remove_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>sequenced_policy</emphasis> execute in sequential order in the calling thread.</para><para>The assignments in the parallel <emphasis>remove_copy_if</emphasis> algorithm invoked with an execution policy object of type <emphasis>parallel_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</para><para><simplesect kind="return"><para>The <emphasis>remove_copy_if</emphasis> algorithm returns a <emphasis>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> &gt; if the execution policy is of type <emphasis>sequenced_task_policy</emphasis> or <emphasis>parallel_task_policy</emphasis> and returns <emphasis>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</emphasis> otherwise. The <emphasis>copy</emphasis> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp" line="350" column="1" bodyfile="libs/algorithms/include/hpx/parallel/algorithms/remove_copy.hpp" bodystart="350" bodyend="367"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="libs/algorithms/include/hpx/parallel/tagspec.hpp" line="16" column="1"/>
  </compounddef>
</doxygen>
